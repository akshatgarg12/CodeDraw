{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar generateRandomKey = require(\"./generateRandomKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar modifyBlockForContentState = require(\"./modifyBlockForContentState\");\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlock, belowBlock) {\n  return blockMap.withMutations(function (blocks) {\n    var originalBlockKey = originalBlock.getKey();\n    var belowBlockKey = belowBlock.getKey(); // update block parent\n\n    transformBlock(originalBlock.getParentKey(), blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;\n      var newChildrenArray = parentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, belowBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    }); // update original next block\n\n    transformBlock(originalBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: belowBlockKey\n      });\n    }); // update original block\n\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: belowBlockKey\n      });\n    }); // update below block\n\n    transformBlock(belowBlockKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    });\n  });\n};\n\nvar splitBlockInContentState = function splitBlockInContentState(contentState, selectionState) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Selection range must be collapsed.') : invariant(false) : void 0;\n  var key = selectionState.getAnchorKey();\n  var blockMap = contentState.getBlockMap();\n  var blockToSplit = blockMap.get(key);\n  var text = blockToSplit.getText();\n\n  if (!text) {\n    var blockType = blockToSplit.getType();\n\n    if (blockType === 'unordered-list-item' || blockType === 'ordered-list-item') {\n      return modifyBlockForContentState(contentState, selectionState, function (block) {\n        return block.merge({\n          type: 'unstyled',\n          depth: 0\n        });\n      });\n    }\n  }\n\n  var offset = selectionState.getAnchorOffset();\n  var chars = blockToSplit.getCharacterList();\n  var keyBelow = generateRandomKey();\n  var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode;\n  var blockAbove = blockToSplit.merge({\n    text: text.slice(0, offset),\n    characterList: chars.slice(0, offset)\n  });\n  var blockBelow = blockAbove.merge({\n    key: keyBelow,\n    text: text.slice(offset),\n    characterList: chars.slice(offset),\n    data: Map()\n  });\n  var blocksBefore = blockMap.toSeq().takeUntil(function (v) {\n    return v === blockToSplit;\n  });\n  var blocksAfter = blockMap.toSeq().skipUntil(function (v) {\n    return v === blockToSplit;\n  }).rest();\n  var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();\n\n  if (isExperimentalTreeBlock) {\n    !blockToSplit.getChildKeys().isEmpty() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ContentBlockNode must not have children') : invariant(false) : void 0;\n    newBlocks = updateBlockMapLinks(newBlocks, blockAbove, blockBelow);\n  }\n\n  return contentState.merge({\n    blockMap: newBlocks,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: keyBelow,\n      anchorOffset: 0,\n      focusKey: keyBelow,\n      focusOffset: 0,\n      isBackward: false\n    })\n  });\n};\n\nmodule.exports = splitBlockInContentState;","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw/node_modules/draft-js/lib/splitBlockInContentState.js"],"names":["ContentBlockNode","require","generateRandomKey","Immutable","invariant","modifyBlockForContentState","List","Map","transformBlock","key","blockMap","func","block","get","set","updateBlockMapLinks","originalBlock","belowBlock","withMutations","blocks","originalBlockKey","getKey","belowBlockKey","getParentKey","parentChildrenList","getChildKeys","insertionIndex","indexOf","newChildrenArray","toArray","splice","merge","children","getNextSiblingKey","prevSibling","nextSibling","splitBlockInContentState","contentState","selectionState","isCollapsed","process","env","NODE_ENV","getAnchorKey","getBlockMap","blockToSplit","text","getText","blockType","getType","type","depth","offset","getAnchorOffset","chars","getCharacterList","keyBelow","isExperimentalTreeBlock","blockAbove","slice","characterList","blockBelow","data","blocksBefore","toSeq","takeUntil","v","blocksAfter","skipUntil","rest","newBlocks","concat","toOrderedMap","isEmpty","selectionBefore","selectionAfter","anchorKey","anchorOffset","focusKey","focusOffset","isBackward","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar ContentBlockNode = require(\"./ContentBlockNode\");\n\nvar generateRandomKey = require(\"./generateRandomKey\");\n\nvar Immutable = require(\"immutable\");\n\nvar invariant = require(\"fbjs/lib/invariant\");\n\nvar modifyBlockForContentState = require(\"./modifyBlockForContentState\");\n\nvar List = Immutable.List,\n    Map = Immutable.Map;\n\nvar transformBlock = function transformBlock(key, blockMap, func) {\n  if (!key) {\n    return;\n  }\n\n  var block = blockMap.get(key);\n\n  if (!block) {\n    return;\n  }\n\n  blockMap.set(key, func(block));\n};\n\nvar updateBlockMapLinks = function updateBlockMapLinks(blockMap, originalBlock, belowBlock) {\n  return blockMap.withMutations(function (blocks) {\n    var originalBlockKey = originalBlock.getKey();\n    var belowBlockKey = belowBlock.getKey(); // update block parent\n\n    transformBlock(originalBlock.getParentKey(), blocks, function (block) {\n      var parentChildrenList = block.getChildKeys();\n      var insertionIndex = parentChildrenList.indexOf(originalBlockKey) + 1;\n      var newChildrenArray = parentChildrenList.toArray();\n      newChildrenArray.splice(insertionIndex, 0, belowBlockKey);\n      return block.merge({\n        children: List(newChildrenArray)\n      });\n    }); // update original next block\n\n    transformBlock(originalBlock.getNextSiblingKey(), blocks, function (block) {\n      return block.merge({\n        prevSibling: belowBlockKey\n      });\n    }); // update original block\n\n    transformBlock(originalBlockKey, blocks, function (block) {\n      return block.merge({\n        nextSibling: belowBlockKey\n      });\n    }); // update below block\n\n    transformBlock(belowBlockKey, blocks, function (block) {\n      return block.merge({\n        prevSibling: originalBlockKey\n      });\n    });\n  });\n};\n\nvar splitBlockInContentState = function splitBlockInContentState(contentState, selectionState) {\n  !selectionState.isCollapsed() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'Selection range must be collapsed.') : invariant(false) : void 0;\n  var key = selectionState.getAnchorKey();\n  var blockMap = contentState.getBlockMap();\n  var blockToSplit = blockMap.get(key);\n  var text = blockToSplit.getText();\n\n  if (!text) {\n    var blockType = blockToSplit.getType();\n\n    if (blockType === 'unordered-list-item' || blockType === 'ordered-list-item') {\n      return modifyBlockForContentState(contentState, selectionState, function (block) {\n        return block.merge({\n          type: 'unstyled',\n          depth: 0\n        });\n      });\n    }\n  }\n\n  var offset = selectionState.getAnchorOffset();\n  var chars = blockToSplit.getCharacterList();\n  var keyBelow = generateRandomKey();\n  var isExperimentalTreeBlock = blockToSplit instanceof ContentBlockNode;\n  var blockAbove = blockToSplit.merge({\n    text: text.slice(0, offset),\n    characterList: chars.slice(0, offset)\n  });\n  var blockBelow = blockAbove.merge({\n    key: keyBelow,\n    text: text.slice(offset),\n    characterList: chars.slice(offset),\n    data: Map()\n  });\n  var blocksBefore = blockMap.toSeq().takeUntil(function (v) {\n    return v === blockToSplit;\n  });\n  var blocksAfter = blockMap.toSeq().skipUntil(function (v) {\n    return v === blockToSplit;\n  }).rest();\n  var newBlocks = blocksBefore.concat([[key, blockAbove], [keyBelow, blockBelow]], blocksAfter).toOrderedMap();\n\n  if (isExperimentalTreeBlock) {\n    !blockToSplit.getChildKeys().isEmpty() ? process.env.NODE_ENV !== \"production\" ? invariant(false, 'ContentBlockNode must not have children') : invariant(false) : void 0;\n    newBlocks = updateBlockMapLinks(newBlocks, blockAbove, blockBelow);\n  }\n\n  return contentState.merge({\n    blockMap: newBlocks,\n    selectionBefore: selectionState,\n    selectionAfter: selectionState.merge({\n      anchorKey: keyBelow,\n      anchorOffset: 0,\n      focusKey: keyBelow,\n      focusOffset: 0,\n      isBackward: false\n    })\n  });\n};\n\nmodule.exports = splitBlockInContentState;"]},"metadata":{},"sourceType":"script"}