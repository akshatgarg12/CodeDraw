{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"slim\", function (config) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"htmlmixed\"\n    });\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n    var modes = {\n      html: htmlMode,\n      ruby: rubyMode\n    };\n    var embedded = {\n      ruby: \"ruby\",\n      javascript: \"javascript\",\n      css: \"text/css\",\n      sass: \"text/x-sass\",\n      scss: \"text/x-scss\",\n      less: \"text/x-less\",\n      styl: \"text/x-styl\",\n      // no highlighting so far\n      coffee: \"coffeescript\",\n      asciidoc: \"text/x-asciidoc\",\n      markdown: \"text/x-markdown\",\n      textile: \"text/x-textile\",\n      // no highlighting so far\n      creole: \"text/x-creole\",\n      // no highlighting so far\n      wiki: \"text/x-wiki\",\n      // no highlighting so far\n      mediawiki: \"text/x-mediawiki\",\n      // no highlighting so far\n      rdoc: \"text/x-rdoc\",\n      // no highlighting so far\n      builder: \"text/x-builder\",\n      // no highlighting so far\n      nokogiri: \"text/x-nokogiri\",\n      // no highlighting so far\n      erb: \"application/x-erb\"\n    };\n\n    var embeddedRegexp = function (map) {\n      var arr = [];\n\n      for (var key in map) arr.push(key);\n\n      return new RegExp(\"^(\" + arr.join('|') + \"):\");\n    }(embedded);\n\n    var styleMap = {\n      \"commentLine\": \"comment\",\n      \"slimSwitch\": \"operator special\",\n      \"slimTag\": \"tag\",\n      \"slimId\": \"attribute def\",\n      \"slimClass\": \"attribute qualifier\",\n      \"slimAttribute\": \"attribute\",\n      \"slimSubmode\": \"keyword special\",\n      \"closeAttributeTag\": null,\n      \"slimDoctype\": null,\n      \"lineContinuation\": null\n    };\n    var closing = {\n      \"{\": \"}\",\n      \"[\": \"]\",\n      \"(\": \")\"\n    };\n    var nameStartChar = \"_a-zA-Z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\n    var nameChar = nameStartChar + \"\\\\-0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040\";\n    var nameRegexp = new RegExp(\"^[:\" + nameStartChar + \"](?::[\" + nameChar + \"]|[\" + nameChar + \"]*)\");\n    var attributeNameRegexp = new RegExp(\"^[:\" + nameStartChar + \"][:\\\\.\" + nameChar + \"]*(?=\\\\s*=)\");\n    var wrappedAttributeNameRegexp = new RegExp(\"^[:\" + nameStartChar + \"][:\\\\.\" + nameChar + \"]*\");\n    var classNameRegexp = /^\\.-?[_a-zA-Z]+[\\w\\-]*/;\n    var classIdRegexp = /^#[_a-zA-Z]+[\\w\\-]*/;\n\n    function backup(pos, tokenize, style) {\n      var restore = function (stream, state) {\n        state.tokenize = tokenize;\n\n        if (stream.pos < pos) {\n          stream.pos = pos;\n          return style;\n        }\n\n        return state.tokenize(stream, state);\n      };\n\n      return function (stream, state) {\n        state.tokenize = restore;\n        return tokenize(stream, state);\n      };\n    }\n\n    function maybeBackup(stream, state, pat, offset, style) {\n      var cur = stream.current();\n      var idx = cur.search(pat);\n\n      if (idx > -1) {\n        state.tokenize = backup(stream.pos, state.tokenize, style);\n        stream.backUp(cur.length - idx - offset);\n      }\n\n      return style;\n    }\n\n    function continueLine(state, column) {\n      state.stack = {\n        parent: state.stack,\n        style: \"continuation\",\n        indented: column,\n        tokenize: state.line\n      };\n      state.line = state.tokenize;\n    }\n\n    function finishContinue(state) {\n      if (state.line == state.tokenize) {\n        state.line = state.stack.tokenize;\n        state.stack = state.stack.parent;\n      }\n    }\n\n    function lineContinuable(column, tokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n\n        if (stream.match(/^\\\\$/)) {\n          continueLine(state, column);\n          return \"lineContinuation\";\n        }\n\n        var style = tokenize(stream, state);\n\n        if (stream.eol() && stream.current().match(/(?:^|[^\\\\])(?:\\\\\\\\)*\\\\$/)) {\n          stream.backUp(1);\n        }\n\n        return style;\n      };\n    }\n\n    function commaContinuable(column, tokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n        var style = tokenize(stream, state);\n\n        if (stream.eol() && stream.current().match(/,$/)) {\n          continueLine(state, column);\n        }\n\n        return style;\n      };\n    }\n\n    function rubyInQuote(endQuote, tokenize) {\n      // TODO: add multi line support\n      return function (stream, state) {\n        var ch = stream.peek();\n\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = tokenize;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n\n    function startRubySplat(tokenize) {\n      var rubyState;\n\n      var runSplat = function (stream, state) {\n        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {\n          stream.backUp(1);\n\n          if (stream.eatSpace()) {\n            state.rubyState = rubyState;\n            state.tokenize = tokenize;\n            return tokenize(stream, state);\n          }\n\n          stream.next();\n        }\n\n        return ruby(stream, state);\n      };\n\n      return function (stream, state) {\n        rubyState = state.rubyState;\n        state.rubyState = CodeMirror.startState(rubyMode);\n        state.tokenize = runSplat;\n        return ruby(stream, state);\n      };\n    }\n\n    function ruby(stream, state) {\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function htmlLine(stream, state) {\n      if (stream.match(/^\\\\$/)) {\n        return \"lineContinuation\";\n      }\n\n      return html(stream, state);\n    }\n\n    function html(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n\n      return maybeBackup(stream, state, /[^\\\\]#\\{/, 1, htmlMode.token(stream, state.htmlState));\n    }\n\n    function startHtmlLine(lastTokenize) {\n      return function (stream, state) {\n        var style = htmlLine(stream, state);\n        if (stream.eol()) state.tokenize = lastTokenize;\n        return style;\n      };\n    }\n\n    function startHtmlMode(stream, state, offset) {\n      state.stack = {\n        parent: state.stack,\n        style: \"html\",\n        indented: stream.column() + offset,\n        // pipe + space\n        tokenize: state.line\n      };\n      state.line = state.tokenize = html;\n      return null;\n    }\n\n    function comment(stream, state) {\n      stream.skipToEnd();\n      return state.stack.style;\n    }\n\n    function commentMode(stream, state) {\n      state.stack = {\n        parent: state.stack,\n        style: \"comment\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = comment;\n      return comment(stream, state);\n    }\n\n    function attributeWrapper(stream, state) {\n      if (stream.eat(state.stack.endQuote)) {\n        state.line = state.stack.line;\n        state.tokenize = state.stack.tokenize;\n        state.stack = state.stack.parent;\n        return null;\n      }\n\n      if (stream.match(wrappedAttributeNameRegexp)) {\n        state.tokenize = attributeWrapperAssign;\n        return \"slimAttribute\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function attributeWrapperAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = attributeWrapperValue;\n        return null;\n      }\n\n      return attributeWrapper(stream, state);\n    }\n\n    function attributeWrapperValue(stream, state) {\n      var ch = stream.peek();\n\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, attributeWrapper);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n\n      if (ch == '[') {\n        return startRubySplat(attributeWrapper)(stream, state);\n      }\n\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = attributeWrapper;\n        return \"keyword\";\n      }\n\n      return startRubySplat(attributeWrapper)(stream, state);\n    }\n\n    function startAttributeWrapperMode(state, endQuote, tokenize) {\n      state.stack = {\n        parent: state.stack,\n        style: \"wrapper\",\n        indented: state.indented + 1,\n        tokenize: tokenize,\n        line: state.line,\n        endQuote: endQuote\n      };\n      state.line = state.tokenize = attributeWrapper;\n      return null;\n    }\n\n    function sub(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n\n      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);\n      subStream.pos = stream.pos - state.stack.indented;\n      subStream.start = stream.start - state.stack.indented;\n      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;\n      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;\n      var style = state.subMode.token(subStream, state.subState);\n      stream.pos = subStream.pos + state.stack.indented;\n      return style;\n    }\n\n    function firstSub(stream, state) {\n      state.stack.indented = stream.column();\n      state.line = state.tokenize = sub;\n      return state.tokenize(stream, state);\n    }\n\n    function createMode(mode) {\n      var query = embedded[mode];\n      var spec = CodeMirror.mimeModes[query];\n\n      if (spec) {\n        return CodeMirror.getMode(config, spec);\n      }\n\n      var factory = CodeMirror.modes[query];\n\n      if (factory) {\n        return factory(config, {\n          name: query\n        });\n      }\n\n      return CodeMirror.getMode(config, \"null\");\n    }\n\n    function getMode(mode) {\n      if (!modes.hasOwnProperty(mode)) {\n        return modes[mode] = createMode(mode);\n      }\n\n      return modes[mode];\n    }\n\n    function startSubMode(mode, state) {\n      var subMode = getMode(mode);\n      var subState = CodeMirror.startState(subMode);\n      state.subMode = subMode;\n      state.subState = subState;\n      state.stack = {\n        parent: state.stack,\n        style: \"sub\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = state.tokenize = firstSub;\n      return \"slimSubmode\";\n    }\n\n    function doctypeLine(stream, _state) {\n      stream.skipToEnd();\n      return \"slimDoctype\";\n    }\n\n    function startLine(stream, state) {\n      var ch = stream.peek();\n\n      if (ch == '<') {\n        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);\n      }\n\n      if (stream.match(/^[|']/)) {\n        return startHtmlMode(stream, state, 1);\n      }\n\n      if (stream.match(/^\\/(!|\\[\\w+])?/)) {\n        return commentMode(stream, state);\n      }\n\n      if (stream.match(/^(-|==?[<>]?)/)) {\n        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));\n        return \"slimSwitch\";\n      }\n\n      if (stream.match(/^doctype\\b/)) {\n        state.tokenize = doctypeLine;\n        return \"keyword\";\n      }\n\n      var m = stream.match(embeddedRegexp);\n\n      if (m) {\n        return startSubMode(m[1], state);\n      }\n\n      return slimTag(stream, state);\n    }\n\n    function slim(stream, state) {\n      if (state.startOfLine) {\n        return startLine(stream, state);\n      }\n\n      return slimTag(stream, state);\n    }\n\n    function slimTag(stream, state) {\n      if (stream.eat('*')) {\n        state.tokenize = startRubySplat(slimTagExtras);\n        return null;\n      }\n\n      if (stream.match(nameRegexp)) {\n        state.tokenize = slimTagExtras;\n        return \"slimTag\";\n      }\n\n      return slimClass(stream, state);\n    }\n\n    function slimTagExtras(stream, state) {\n      if (stream.match(/^(<>?|><?)/)) {\n        state.tokenize = slimClass;\n        return null;\n      }\n\n      return slimClass(stream, state);\n    }\n\n    function slimClass(stream, state) {\n      if (stream.match(classIdRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimId\";\n      }\n\n      if (stream.match(classNameRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimClass\";\n      }\n\n      return slimAttribute(stream, state);\n    }\n\n    function slimAttribute(stream, state) {\n      if (stream.match(/^([\\[\\{\\(])/)) {\n        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);\n      }\n\n      if (stream.match(attributeNameRegexp)) {\n        state.tokenize = slimAttributeAssign;\n        return \"slimAttribute\";\n      }\n\n      if (stream.peek() == '*') {\n        stream.next();\n        state.tokenize = startRubySplat(slimContent);\n        return null;\n      }\n\n      return slimContent(stream, state);\n    }\n\n    function slimAttributeAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = slimAttributeValue;\n        return null;\n      } // should never happen, because of forward lookup\n\n\n      return slimAttribute(stream, state);\n    }\n\n    function slimAttributeValue(stream, state) {\n      var ch = stream.peek();\n\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, slimAttribute);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n\n      if (ch == '[') {\n        return startRubySplat(slimAttribute)(stream, state);\n      }\n\n      if (ch == ':') {\n        return startRubySplat(slimAttributeSymbols)(stream, state);\n      }\n\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = slimAttribute;\n        return \"keyword\";\n      }\n\n      return startRubySplat(slimAttribute)(stream, state);\n    }\n\n    function slimAttributeSymbols(stream, state) {\n      stream.backUp(1);\n\n      if (stream.match(/^[^\\s],(?=:)/)) {\n        state.tokenize = startRubySplat(slimAttributeSymbols);\n        return null;\n      }\n\n      stream.next();\n      return slimAttribute(stream, state);\n    }\n\n    function readQuoted(quote, style, embed, unescaped, nextTokenize) {\n      return function (stream, state) {\n        finishContinue(state);\n        var fresh = stream.current().length == 0;\n\n        if (stream.match(/^\\\\$/, fresh)) {\n          if (!fresh) return style;\n          continueLine(state, state.indented);\n          return \"lineContinuation\";\n        }\n\n        if (stream.match(/^#\\{/, fresh)) {\n          if (!fresh) return style;\n          state.tokenize = rubyInQuote(\"}\", state.tokenize);\n          return null;\n        }\n\n        var escaped = false,\n            ch;\n\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && (unescaped || !escaped)) {\n            state.tokenize = nextTokenize;\n            break;\n          }\n\n          if (embed && ch == \"#\" && !escaped) {\n            if (stream.eat(\"{\")) {\n              stream.backUp(2);\n              break;\n            }\n          }\n\n          escaped = !escaped && ch == \"\\\\\";\n        }\n\n        if (stream.eol() && escaped) {\n          stream.backUp(1);\n        }\n\n        return style;\n      };\n    }\n\n    function slimContent(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = ruby;\n        return \"slimSwitch\";\n      }\n\n      if (stream.match(/^\\/$/)) {\n        // tag close hint\n        state.tokenize = slim;\n        return null;\n      }\n\n      if (stream.match(/^:/)) {\n        // inline tag\n        state.tokenize = slimTag;\n        return \"slimSwitch\";\n      }\n\n      startHtmlMode(stream, state, 0);\n      return state.tokenize(stream, state);\n    }\n\n    var mode = {\n      // default to html mode\n      startState: function () {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          stack: null,\n          last: null,\n          tokenize: slim,\n          line: slim,\n          indented: 0\n        };\n      },\n      copyState: function (state) {\n        return {\n          htmlState: CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          subMode: state.subMode,\n          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),\n          stack: state.stack,\n          last: state.last,\n          tokenize: state.tokenize,\n          line: state.line\n        };\n      },\n      token: function (stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          state.tokenize = state.line;\n\n          while (state.stack && state.stack.indented > state.indented && state.last != \"slimSubmode\") {\n            state.line = state.tokenize = state.stack.tokenize;\n            state.stack = state.stack.parent;\n            state.subMode = null;\n            state.subState = null;\n          }\n        }\n\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        if (style) state.last = style;\n        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;\n      },\n      blankLine: function (state) {\n        if (state.subMode && state.subMode.blankLine) {\n          return state.subMode.blankLine(state.subState);\n        }\n      },\n      innerMode: function (state) {\n        if (state.subMode) return {\n          state: state.subState,\n          mode: state.subMode\n        };\n        return {\n          state: state,\n          mode: mode\n        };\n      } //indent: function(state) {\n      //  return state.indented;\n      //}\n\n    };\n    return mode;\n  }, \"htmlmixed\", \"ruby\");\n  CodeMirror.defineMIME(\"text/x-slim\", \"slim\");\n  CodeMirror.defineMIME(\"application/x-slim\", \"slim\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/slim/slim.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","htmlMode","getMode","name","rubyMode","modes","html","ruby","embedded","javascript","css","sass","scss","less","styl","coffee","asciidoc","markdown","textile","creole","wiki","mediawiki","rdoc","builder","nokogiri","erb","embeddedRegexp","map","arr","key","push","RegExp","join","styleMap","closing","nameStartChar","nameChar","nameRegexp","attributeNameRegexp","wrappedAttributeNameRegexp","classNameRegexp","classIdRegexp","backup","pos","tokenize","style","restore","stream","state","maybeBackup","pat","offset","cur","current","idx","search","backUp","length","continueLine","column","stack","parent","indented","line","finishContinue","lineContinuable","match","eol","commaContinuable","rubyInQuote","endQuote","ch","peek","rubyState","next","startRubySplat","runSplat","context","prev","eatSpace","startState","token","htmlLine","htmlState","startHtmlLine","lastTokenize","startHtmlMode","comment","skipToEnd","commentMode","attributeWrapper","eat","attributeWrapperAssign","attributeWrapperValue","readQuoted","startAttributeWrapperMode","sub","subStream","StringStream","string","slice","tabSize","start","lastColumnPos","lastColumnValue","subMode","subState","firstSub","createMode","mode","query","spec","mimeModes","factory","hasOwnProperty","startSubMode","doctypeLine","_state","startLine","m","slimTag","slim","startOfLine","slimTagExtras","slimClass","slimAttribute","$1","slimAttributeAssign","slimContent","slimAttributeValue","slimAttributeSymbols","quote","embed","unescaped","nextTokenize","fresh","escaped","last","copyState","sol","indentation","blankLine","innerMode","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Slim Highlighting for CodeMirror copyright (c) HicknHack Software Gmbh\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n  CodeMirror.defineMode(\"slim\", function(config) {\n    var htmlMode = CodeMirror.getMode(config, {name: \"htmlmixed\"});\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n    var modes = { html: htmlMode, ruby: rubyMode };\n    var embedded = {\n      ruby: \"ruby\",\n      javascript: \"javascript\",\n      css: \"text/css\",\n      sass: \"text/x-sass\",\n      scss: \"text/x-scss\",\n      less: \"text/x-less\",\n      styl: \"text/x-styl\", // no highlighting so far\n      coffee: \"coffeescript\",\n      asciidoc: \"text/x-asciidoc\",\n      markdown: \"text/x-markdown\",\n      textile: \"text/x-textile\", // no highlighting so far\n      creole: \"text/x-creole\", // no highlighting so far\n      wiki: \"text/x-wiki\", // no highlighting so far\n      mediawiki: \"text/x-mediawiki\", // no highlighting so far\n      rdoc: \"text/x-rdoc\", // no highlighting so far\n      builder: \"text/x-builder\", // no highlighting so far\n      nokogiri: \"text/x-nokogiri\", // no highlighting so far\n      erb: \"application/x-erb\"\n    };\n    var embeddedRegexp = function(map){\n      var arr = [];\n      for(var key in map) arr.push(key);\n      return new RegExp(\"^(\"+arr.join('|')+\"):\");\n    }(embedded);\n\n    var styleMap = {\n      \"commentLine\": \"comment\",\n      \"slimSwitch\": \"operator special\",\n      \"slimTag\": \"tag\",\n      \"slimId\": \"attribute def\",\n      \"slimClass\": \"attribute qualifier\",\n      \"slimAttribute\": \"attribute\",\n      \"slimSubmode\": \"keyword special\",\n      \"closeAttributeTag\": null,\n      \"slimDoctype\": null,\n      \"lineContinuation\": null\n    };\n    var closing = {\n      \"{\": \"}\",\n      \"[\": \"]\",\n      \"(\": \")\"\n    };\n\n    var nameStartChar = \"_a-zA-Z\\xC0-\\xD6\\xD8-\\xF6\\xF8-\\u02FF\\u0370-\\u037D\\u037F-\\u1FFF\\u200C-\\u200D\\u2070-\\u218F\\u2C00-\\u2FEF\\u3001-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFFD\";\n    var nameChar = nameStartChar + \"\\\\-0-9\\xB7\\u0300-\\u036F\\u203F-\\u2040\";\n    var nameRegexp = new RegExp(\"^[:\"+nameStartChar+\"](?::[\"+nameChar+\"]|[\"+nameChar+\"]*)\");\n    var attributeNameRegexp = new RegExp(\"^[:\"+nameStartChar+\"][:\\\\.\"+nameChar+\"]*(?=\\\\s*=)\");\n    var wrappedAttributeNameRegexp = new RegExp(\"^[:\"+nameStartChar+\"][:\\\\.\"+nameChar+\"]*\");\n    var classNameRegexp = /^\\.-?[_a-zA-Z]+[\\w\\-]*/;\n    var classIdRegexp = /^#[_a-zA-Z]+[\\w\\-]*/;\n\n    function backup(pos, tokenize, style) {\n      var restore = function(stream, state) {\n        state.tokenize = tokenize;\n        if (stream.pos < pos) {\n          stream.pos = pos;\n          return style;\n        }\n        return state.tokenize(stream, state);\n      };\n      return function(stream, state) {\n        state.tokenize = restore;\n        return tokenize(stream, state);\n      };\n    }\n\n    function maybeBackup(stream, state, pat, offset, style) {\n      var cur = stream.current();\n      var idx = cur.search(pat);\n      if (idx > -1) {\n        state.tokenize = backup(stream.pos, state.tokenize, style);\n        stream.backUp(cur.length - idx - offset);\n      }\n      return style;\n    }\n\n    function continueLine(state, column) {\n      state.stack = {\n        parent: state.stack,\n        style: \"continuation\",\n        indented: column,\n        tokenize: state.line\n      };\n      state.line = state.tokenize;\n    }\n    function finishContinue(state) {\n      if (state.line == state.tokenize) {\n        state.line = state.stack.tokenize;\n        state.stack = state.stack.parent;\n      }\n    }\n\n    function lineContinuable(column, tokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        if (stream.match(/^\\\\$/)) {\n          continueLine(state, column);\n          return \"lineContinuation\";\n        }\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/(?:^|[^\\\\])(?:\\\\\\\\)*\\\\$/)) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function commaContinuable(column, tokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        var style = tokenize(stream, state);\n        if (stream.eol() && stream.current().match(/,$/)) {\n          continueLine(state, column);\n        }\n        return style;\n      };\n    }\n\n    function rubyInQuote(endQuote, tokenize) {\n      // TODO: add multi line support\n      return function(stream, state) {\n        var ch = stream.peek();\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = tokenize;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n    function startRubySplat(tokenize) {\n      var rubyState;\n      var runSplat = function(stream, state) {\n        if (state.rubyState.tokenize.length == 1 && !state.rubyState.context.prev) {\n          stream.backUp(1);\n          if (stream.eatSpace()) {\n            state.rubyState = rubyState;\n            state.tokenize = tokenize;\n            return tokenize(stream, state);\n          }\n          stream.next();\n        }\n        return ruby(stream, state);\n      };\n      return function(stream, state) {\n        rubyState = state.rubyState;\n        state.rubyState = CodeMirror.startState(rubyMode);\n        state.tokenize = runSplat;\n        return ruby(stream, state);\n      };\n    }\n\n    function ruby(stream, state) {\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function htmlLine(stream, state) {\n      if (stream.match(/^\\\\$/)) {\n        return \"lineContinuation\";\n      }\n      return html(stream, state);\n    }\n    function html(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      return maybeBackup(stream, state, /[^\\\\]#\\{/, 1, htmlMode.token(stream, state.htmlState));\n    }\n\n    function startHtmlLine(lastTokenize) {\n      return function(stream, state) {\n        var style = htmlLine(stream, state);\n        if (stream.eol()) state.tokenize = lastTokenize;\n        return style;\n      };\n    }\n\n    function startHtmlMode(stream, state, offset) {\n      state.stack = {\n        parent: state.stack,\n        style: \"html\",\n        indented: stream.column() + offset, // pipe + space\n        tokenize: state.line\n      };\n      state.line = state.tokenize = html;\n      return null;\n    }\n\n    function comment(stream, state) {\n      stream.skipToEnd();\n      return state.stack.style;\n    }\n\n    function commentMode(stream, state) {\n      state.stack = {\n        parent: state.stack,\n        style: \"comment\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = comment;\n      return comment(stream, state);\n    }\n\n    function attributeWrapper(stream, state) {\n      if (stream.eat(state.stack.endQuote)) {\n        state.line = state.stack.line;\n        state.tokenize = state.stack.tokenize;\n        state.stack = state.stack.parent;\n        return null;\n      }\n      if (stream.match(wrappedAttributeNameRegexp)) {\n        state.tokenize = attributeWrapperAssign;\n        return \"slimAttribute\";\n      }\n      stream.next();\n      return null;\n    }\n    function attributeWrapperAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = attributeWrapperValue;\n        return null;\n      }\n      return attributeWrapper(stream, state);\n    }\n    function attributeWrapperValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, attributeWrapper);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(attributeWrapper)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = attributeWrapper;\n        return \"keyword\";\n      }\n      return startRubySplat(attributeWrapper)(stream, state);\n    }\n\n    function startAttributeWrapperMode(state, endQuote, tokenize) {\n      state.stack = {\n        parent: state.stack,\n        style: \"wrapper\",\n        indented: state.indented + 1,\n        tokenize: tokenize,\n        line: state.line,\n        endQuote: endQuote\n      };\n      state.line = state.tokenize = attributeWrapper;\n      return null;\n    }\n\n    function sub(stream, state) {\n      if (stream.match(/^#\\{/)) {\n        state.tokenize = rubyInQuote(\"}\", state.tokenize);\n        return null;\n      }\n      var subStream = new CodeMirror.StringStream(stream.string.slice(state.stack.indented), stream.tabSize);\n      subStream.pos = stream.pos - state.stack.indented;\n      subStream.start = stream.start - state.stack.indented;\n      subStream.lastColumnPos = stream.lastColumnPos - state.stack.indented;\n      subStream.lastColumnValue = stream.lastColumnValue - state.stack.indented;\n      var style = state.subMode.token(subStream, state.subState);\n      stream.pos = subStream.pos + state.stack.indented;\n      return style;\n    }\n    function firstSub(stream, state) {\n      state.stack.indented = stream.column();\n      state.line = state.tokenize = sub;\n      return state.tokenize(stream, state);\n    }\n\n    function createMode(mode) {\n      var query = embedded[mode];\n      var spec = CodeMirror.mimeModes[query];\n      if (spec) {\n        return CodeMirror.getMode(config, spec);\n      }\n      var factory = CodeMirror.modes[query];\n      if (factory) {\n        return factory(config, {name: query});\n      }\n      return CodeMirror.getMode(config, \"null\");\n    }\n\n    function getMode(mode) {\n      if (!modes.hasOwnProperty(mode)) {\n        return modes[mode] = createMode(mode);\n      }\n      return modes[mode];\n    }\n\n    function startSubMode(mode, state) {\n      var subMode = getMode(mode);\n      var subState = CodeMirror.startState(subMode);\n\n      state.subMode = subMode;\n      state.subState = subState;\n\n      state.stack = {\n        parent: state.stack,\n        style: \"sub\",\n        indented: state.indented + 1,\n        tokenize: state.line\n      };\n      state.line = state.tokenize = firstSub;\n      return \"slimSubmode\";\n    }\n\n    function doctypeLine(stream, _state) {\n      stream.skipToEnd();\n      return \"slimDoctype\";\n    }\n\n    function startLine(stream, state) {\n      var ch = stream.peek();\n      if (ch == '<') {\n        return (state.tokenize = startHtmlLine(state.tokenize))(stream, state);\n      }\n      if (stream.match(/^[|']/)) {\n        return startHtmlMode(stream, state, 1);\n      }\n      if (stream.match(/^\\/(!|\\[\\w+])?/)) {\n        return commentMode(stream, state);\n      }\n      if (stream.match(/^(-|==?[<>]?)/)) {\n        state.tokenize = lineContinuable(stream.column(), commaContinuable(stream.column(), ruby));\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^doctype\\b/)) {\n        state.tokenize = doctypeLine;\n        return \"keyword\";\n      }\n\n      var m = stream.match(embeddedRegexp);\n      if (m) {\n        return startSubMode(m[1], state);\n      }\n\n      return slimTag(stream, state);\n    }\n\n    function slim(stream, state) {\n      if (state.startOfLine) {\n        return startLine(stream, state);\n      }\n      return slimTag(stream, state);\n    }\n\n    function slimTag(stream, state) {\n      if (stream.eat('*')) {\n        state.tokenize = startRubySplat(slimTagExtras);\n        return null;\n      }\n      if (stream.match(nameRegexp)) {\n        state.tokenize = slimTagExtras;\n        return \"slimTag\";\n      }\n      return slimClass(stream, state);\n    }\n    function slimTagExtras(stream, state) {\n      if (stream.match(/^(<>?|><?)/)) {\n        state.tokenize = slimClass;\n        return null;\n      }\n      return slimClass(stream, state);\n    }\n    function slimClass(stream, state) {\n      if (stream.match(classIdRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimId\";\n      }\n      if (stream.match(classNameRegexp)) {\n        state.tokenize = slimClass;\n        return \"slimClass\";\n      }\n      return slimAttribute(stream, state);\n    }\n    function slimAttribute(stream, state) {\n      if (stream.match(/^([\\[\\{\\(])/)) {\n        return startAttributeWrapperMode(state, closing[RegExp.$1], slimAttribute);\n      }\n      if (stream.match(attributeNameRegexp)) {\n        state.tokenize = slimAttributeAssign;\n        return \"slimAttribute\";\n      }\n      if (stream.peek() == '*') {\n        stream.next();\n        state.tokenize = startRubySplat(slimContent);\n        return null;\n      }\n      return slimContent(stream, state);\n    }\n    function slimAttributeAssign(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = slimAttributeValue;\n        return null;\n      }\n      // should never happen, because of forward lookup\n      return slimAttribute(stream, state);\n    }\n\n    function slimAttributeValue(stream, state) {\n      var ch = stream.peek();\n      if (ch == '\"' || ch == \"\\'\") {\n        state.tokenize = readQuoted(ch, \"string\", true, false, slimAttribute);\n        stream.next();\n        return state.tokenize(stream, state);\n      }\n      if (ch == '[') {\n        return startRubySplat(slimAttribute)(stream, state);\n      }\n      if (ch == ':') {\n        return startRubySplat(slimAttributeSymbols)(stream, state);\n      }\n      if (stream.match(/^(true|false|nil)\\b/)) {\n        state.tokenize = slimAttribute;\n        return \"keyword\";\n      }\n      return startRubySplat(slimAttribute)(stream, state);\n    }\n    function slimAttributeSymbols(stream, state) {\n      stream.backUp(1);\n      if (stream.match(/^[^\\s],(?=:)/)) {\n        state.tokenize = startRubySplat(slimAttributeSymbols);\n        return null;\n      }\n      stream.next();\n      return slimAttribute(stream, state);\n    }\n    function readQuoted(quote, style, embed, unescaped, nextTokenize) {\n      return function(stream, state) {\n        finishContinue(state);\n        var fresh = stream.current().length == 0;\n        if (stream.match(/^\\\\$/, fresh)) {\n          if (!fresh) return style;\n          continueLine(state, state.indented);\n          return \"lineContinuation\";\n        }\n        if (stream.match(/^#\\{/, fresh)) {\n          if (!fresh) return style;\n          state.tokenize = rubyInQuote(\"}\", state.tokenize);\n          return null;\n        }\n        var escaped = false, ch;\n        while ((ch = stream.next()) != null) {\n          if (ch == quote && (unescaped || !escaped)) {\n            state.tokenize = nextTokenize;\n            break;\n          }\n          if (embed && ch == \"#\" && !escaped) {\n            if (stream.eat(\"{\")) {\n              stream.backUp(2);\n              break;\n            }\n          }\n          escaped = !escaped && ch == \"\\\\\";\n        }\n        if (stream.eol() && escaped) {\n          stream.backUp(1);\n        }\n        return style;\n      };\n    }\n    function slimContent(stream, state) {\n      if (stream.match(/^==?/)) {\n        state.tokenize = ruby;\n        return \"slimSwitch\";\n      }\n      if (stream.match(/^\\/$/)) { // tag close hint\n        state.tokenize = slim;\n        return null;\n      }\n      if (stream.match(/^:/)) { // inline tag\n        state.tokenize = slimTag;\n        return \"slimSwitch\";\n      }\n      startHtmlMode(stream, state, 0);\n      return state.tokenize(stream, state);\n    }\n\n    var mode = {\n      // default to html mode\n      startState: function() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          stack: null,\n          last: null,\n          tokenize: slim,\n          line: slim,\n          indented: 0\n        };\n      },\n\n      copyState: function(state) {\n        return {\n          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          subMode: state.subMode,\n          subState: state.subMode && CodeMirror.copyState(state.subMode, state.subState),\n          stack: state.stack,\n          last: state.last,\n          tokenize: state.tokenize,\n          line: state.line\n        };\n      },\n\n      token: function(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n          state.tokenize = state.line;\n          while (state.stack && state.stack.indented > state.indented && state.last != \"slimSubmode\") {\n            state.line = state.tokenize = state.stack.tokenize;\n            state.stack = state.stack.parent;\n            state.subMode = null;\n            state.subState = null;\n          }\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        if (style) state.last = style;\n        return styleMap.hasOwnProperty(style) ? styleMap[style] : style;\n      },\n\n      blankLine: function(state) {\n        if (state.subMode && state.subMode.blankLine) {\n          return state.subMode.blankLine(state.subState);\n        }\n      },\n\n      innerMode: function(state) {\n        if (state.subMode) return {state: state.subState, mode: state.subMode};\n        return {state: state, mode: mode};\n      }\n\n      //indent: function(state) {\n      //  return state.indented;\n      //}\n    };\n    return mode;\n  }, \"htmlmixed\", \"ruby\");\n\n  CodeMirror.defineMIME(\"text/x-slim\", \"slim\");\n  CodeMirror.defineMIME(\"application/x-slim\", \"slim\");\n});\n"]},"metadata":{},"sourceType":"script"}