{"ast":null,"code":"/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar DraftModifier = require(\"./DraftModifier\");\n\nvar EditorState = require(\"./EditorState\");\n\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\n\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\n\nvar isEventHandled = require(\"./isEventHandled\");\n\nvar isSelectionAtLeafStart = require(\"./isSelectionAtLeafStart\");\n\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n\nvar setImmediate = require(\"fbjs/lib/setImmediate\"); // When nothing is focused, Firefox regards two characters, `'` and `/`, as\n// commands that should open and focus the \"quickfind\" search bar. This should\n// *never* happen while a contenteditable is focused, but as of v28, it\n// sometimes does, even when the keypress event target is the contenteditable.\n// This breaks the input. Special case these characters to ensure that when\n// they are typed, we prevent default on the event to make sure not to\n// trigger quickfind.\n\n\nvar FF_QUICKFIND_CHAR = \"'\";\nvar FF_QUICKFIND_LINK_CHAR = '/';\nvar isFirefox = UserAgent.isBrowser('Firefox');\n\nfunction mustPreventDefaultForCharacter(character) {\n  return isFirefox && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);\n}\n/**\n * Replace the current selection with the specified text string, with the\n * inline style and entity key applied to the newly inserted text.\n */\n\n\nfunction replaceText(editorState, text, inlineStyle, entityKey, forceSelection) {\n  var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);\n  return EditorState.push(editorState, contentState, 'insert-characters', forceSelection);\n}\n/**\n * When `onBeforeInput` executes, the browser is attempting to insert a\n * character into the editor. Apply this character data to the document,\n * allowing native insertion if possible.\n *\n * Native insertion is encouraged in order to limit re-rendering and to\n * preserve spellcheck highlighting, which disappears or flashes if re-render\n * occurs on the relevant text nodes.\n */\n\n\nfunction editOnBeforeInput(editor, e) {\n  if (editor._pendingStateFromBeforeInput !== undefined) {\n    editor.update(editor._pendingStateFromBeforeInput);\n    editor._pendingStateFromBeforeInput = undefined;\n  }\n\n  var editorState = editor._latestEditorState;\n  var chars = e.data; // In some cases (ex: IE ideographic space insertion) no character data\n  // is provided. There's nothing to do when this happens.\n\n  if (!chars) {\n    return;\n  } // Allow the top-level component to handle the insertion manually. This is\n  // useful when triggering interesting behaviors for a character insertion,\n  // Simple examples: replacing a raw text ':)' with a smile emoji or image\n  // decorator, or setting a block to be a list item after typing '- ' at the\n  // start of the block.\n\n\n  if (editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(chars, editorState, e.timeStamp))) {\n    e.preventDefault();\n    return;\n  } // If selection is collapsed, conditionally allow native behavior. This\n  // reduces re-renders and preserves spellcheck highlighting. If the selection\n  // is not collapsed, we will re-render.\n\n\n  var selection = editorState.getSelection();\n  var selectionStart = selection.getStartOffset();\n  var anchorKey = selection.getAnchorKey();\n\n  if (!selection.isCollapsed()) {\n    e.preventDefault();\n    editor.update(replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), true));\n    return;\n  }\n\n  var newEditorState = replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), false); // Bunch of different cases follow where we need to prevent native insertion.\n\n  var mustPreventNative = false;\n\n  if (!mustPreventNative) {\n    // Browsers tend to insert text in weird places in the DOM when typing at\n    // the start of a leaf, so we'll handle it ourselves.\n    mustPreventNative = isSelectionAtLeafStart(editor._latestCommittedEditorState);\n  }\n\n  if (!mustPreventNative) {\n    // Let's say we have a decorator that highlights hashtags. In many cases\n    // we need to prevent native behavior and rerender ourselves --\n    // particularly, any case *except* where the inserted characters end up\n    // anywhere except exactly where you put them.\n    //\n    // Using [] to denote a decorated leaf, some examples:\n    //\n    // 1. 'hi #' and append 'f'\n    // desired rendering: 'hi [#f]'\n    // native rendering would be: 'hi #f' (incorrect)\n    //\n    // 2. 'x [#foo]' and insert '#' before 'f'\n    // desired rendering: 'x #[#foo]'\n    // native rendering would be: 'x [##foo]' (incorrect)\n    //\n    // 3. '[#foobar]' and insert ' ' between 'foo' and 'bar'\n    // desired rendering: '[#foo] bar'\n    // native rendering would be: '[#foo bar]' (incorrect)\n    //\n    // 4. '[#foo]' and delete '#' [won't use this beforeinput codepath though]\n    // desired rendering: 'foo'\n    // native rendering would be: '[foo]' (incorrect)\n    //\n    // 5. '[#foo]' and append 'b'\n    // desired rendering: '[#foob]'\n    // native rendering would be: '[#foob]'\n    // (native insertion here would be ok for decorators like simple spans,\n    // but not more complex decorators. To be safe, we need to prevent it.)\n    //\n    // It is safe to allow native insertion if and only if the full list of\n    // decorator ranges matches what we expect native insertion to give, and\n    // the range lengths have not changed. We don't need to compare the content\n    // because the only possible mutation to consider here is inserting plain\n    // text and decorators can't affect text content.\n    var oldBlockTree = editorState.getBlockTree(anchorKey);\n    var newBlockTree = newEditorState.getBlockTree(anchorKey);\n    mustPreventNative = oldBlockTree.size !== newBlockTree.size || oldBlockTree.zip(newBlockTree).some(function (_ref) {\n      var oldLeafSet = _ref[0],\n          newLeafSet = _ref[1]; // selectionStart is guaranteed to be selectionEnd here\n\n      var oldStart = oldLeafSet.get('start');\n      var adjustedStart = oldStart + (oldStart >= selectionStart ? chars.length : 0);\n      var oldEnd = oldLeafSet.get('end');\n      var adjustedEnd = oldEnd + (oldEnd >= selectionStart ? chars.length : 0);\n      var newStart = newLeafSet.get('start');\n      var newEnd = newLeafSet.get('end');\n      var newDecoratorKey = newLeafSet.get('decoratorKey');\n      return (// Different decorators\n        oldLeafSet.get('decoratorKey') !== newDecoratorKey || // Different number of inline styles\n        oldLeafSet.get('leaves').size !== newLeafSet.get('leaves').size || // Different effective decorator position\n        adjustedStart !== newStart || adjustedEnd !== newEnd || // Decorator already existed and its length changed\n        newDecoratorKey != null && newEnd - newStart !== oldEnd - oldStart\n      );\n    });\n  }\n\n  if (!mustPreventNative) {\n    mustPreventNative = mustPreventDefaultForCharacter(chars);\n  }\n\n  if (!mustPreventNative) {\n    mustPreventNative = nullthrows(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows(editorState.getDirectionMap()).get(anchorKey);\n  }\n\n  if (mustPreventNative) {\n    e.preventDefault();\n    newEditorState = EditorState.set(newEditorState, {\n      forceSelection: true\n    });\n    editor.update(newEditorState);\n    return;\n  } // We made it all the way! Let the browser do its thing and insert the char.\n\n\n  newEditorState = EditorState.set(newEditorState, {\n    nativelyRenderedContent: newEditorState.getCurrentContent()\n  }); // The native event is allowed to occur. To allow user onChange handlers to\n  // change the inserted text, we wait until the text is actually inserted\n  // before we actually update our state. That way when we rerender, the text\n  // we see in the DOM will already have been inserted properly.\n\n  editor._pendingStateFromBeforeInput = newEditorState;\n  setImmediate(function () {\n    if (editor._pendingStateFromBeforeInput !== undefined) {\n      editor.update(editor._pendingStateFromBeforeInput);\n      editor._pendingStateFromBeforeInput = undefined;\n    }\n  });\n}\n\nmodule.exports = editOnBeforeInput;","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw/node_modules/draft-js/lib/editOnBeforeInput.js"],"names":["DraftModifier","require","EditorState","UserAgent","getEntityKeyForSelection","isEventHandled","isSelectionAtLeafStart","nullthrows","setImmediate","FF_QUICKFIND_CHAR","FF_QUICKFIND_LINK_CHAR","isFirefox","isBrowser","mustPreventDefaultForCharacter","character","replaceText","editorState","text","inlineStyle","entityKey","forceSelection","contentState","getCurrentContent","getSelection","push","editOnBeforeInput","editor","e","_pendingStateFromBeforeInput","undefined","update","_latestEditorState","chars","data","props","handleBeforeInput","timeStamp","preventDefault","selection","selectionStart","getStartOffset","anchorKey","getAnchorKey","isCollapsed","getCurrentInlineStyle","newEditorState","mustPreventNative","_latestCommittedEditorState","oldBlockTree","getBlockTree","newBlockTree","size","zip","some","_ref","oldLeafSet","newLeafSet","oldStart","get","adjustedStart","length","oldEnd","adjustedEnd","newStart","newEnd","newDecoratorKey","getDirectionMap","set","nativelyRenderedContent","module","exports"],"mappings":"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","sourcesContent":["/**\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n *\n * @format\n * \n * @emails oncall+draft_js\n */\n'use strict';\n\nvar DraftModifier = require(\"./DraftModifier\");\n\nvar EditorState = require(\"./EditorState\");\n\nvar UserAgent = require(\"fbjs/lib/UserAgent\");\n\nvar getEntityKeyForSelection = require(\"./getEntityKeyForSelection\");\n\nvar isEventHandled = require(\"./isEventHandled\");\n\nvar isSelectionAtLeafStart = require(\"./isSelectionAtLeafStart\");\n\nvar nullthrows = require(\"fbjs/lib/nullthrows\");\n\nvar setImmediate = require(\"fbjs/lib/setImmediate\"); // When nothing is focused, Firefox regards two characters, `'` and `/`, as\n// commands that should open and focus the \"quickfind\" search bar. This should\n// *never* happen while a contenteditable is focused, but as of v28, it\n// sometimes does, even when the keypress event target is the contenteditable.\n// This breaks the input. Special case these characters to ensure that when\n// they are typed, we prevent default on the event to make sure not to\n// trigger quickfind.\n\n\nvar FF_QUICKFIND_CHAR = \"'\";\nvar FF_QUICKFIND_LINK_CHAR = '/';\nvar isFirefox = UserAgent.isBrowser('Firefox');\n\nfunction mustPreventDefaultForCharacter(character) {\n  return isFirefox && (character == FF_QUICKFIND_CHAR || character == FF_QUICKFIND_LINK_CHAR);\n}\n/**\n * Replace the current selection with the specified text string, with the\n * inline style and entity key applied to the newly inserted text.\n */\n\n\nfunction replaceText(editorState, text, inlineStyle, entityKey, forceSelection) {\n  var contentState = DraftModifier.replaceText(editorState.getCurrentContent(), editorState.getSelection(), text, inlineStyle, entityKey);\n  return EditorState.push(editorState, contentState, 'insert-characters', forceSelection);\n}\n/**\n * When `onBeforeInput` executes, the browser is attempting to insert a\n * character into the editor. Apply this character data to the document,\n * allowing native insertion if possible.\n *\n * Native insertion is encouraged in order to limit re-rendering and to\n * preserve spellcheck highlighting, which disappears or flashes if re-render\n * occurs on the relevant text nodes.\n */\n\n\nfunction editOnBeforeInput(editor, e) {\n  if (editor._pendingStateFromBeforeInput !== undefined) {\n    editor.update(editor._pendingStateFromBeforeInput);\n    editor._pendingStateFromBeforeInput = undefined;\n  }\n\n  var editorState = editor._latestEditorState;\n  var chars = e.data; // In some cases (ex: IE ideographic space insertion) no character data\n  // is provided. There's nothing to do when this happens.\n\n  if (!chars) {\n    return;\n  } // Allow the top-level component to handle the insertion manually. This is\n  // useful when triggering interesting behaviors for a character insertion,\n  // Simple examples: replacing a raw text ':)' with a smile emoji or image\n  // decorator, or setting a block to be a list item after typing '- ' at the\n  // start of the block.\n\n\n  if (editor.props.handleBeforeInput && isEventHandled(editor.props.handleBeforeInput(chars, editorState, e.timeStamp))) {\n    e.preventDefault();\n    return;\n  } // If selection is collapsed, conditionally allow native behavior. This\n  // reduces re-renders and preserves spellcheck highlighting. If the selection\n  // is not collapsed, we will re-render.\n\n\n  var selection = editorState.getSelection();\n  var selectionStart = selection.getStartOffset();\n  var anchorKey = selection.getAnchorKey();\n\n  if (!selection.isCollapsed()) {\n    e.preventDefault();\n    editor.update(replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), true));\n    return;\n  }\n\n  var newEditorState = replaceText(editorState, chars, editorState.getCurrentInlineStyle(), getEntityKeyForSelection(editorState.getCurrentContent(), editorState.getSelection()), false); // Bunch of different cases follow where we need to prevent native insertion.\n\n  var mustPreventNative = false;\n\n  if (!mustPreventNative) {\n    // Browsers tend to insert text in weird places in the DOM when typing at\n    // the start of a leaf, so we'll handle it ourselves.\n    mustPreventNative = isSelectionAtLeafStart(editor._latestCommittedEditorState);\n  }\n\n  if (!mustPreventNative) {\n    // Let's say we have a decorator that highlights hashtags. In many cases\n    // we need to prevent native behavior and rerender ourselves --\n    // particularly, any case *except* where the inserted characters end up\n    // anywhere except exactly where you put them.\n    //\n    // Using [] to denote a decorated leaf, some examples:\n    //\n    // 1. 'hi #' and append 'f'\n    // desired rendering: 'hi [#f]'\n    // native rendering would be: 'hi #f' (incorrect)\n    //\n    // 2. 'x [#foo]' and insert '#' before 'f'\n    // desired rendering: 'x #[#foo]'\n    // native rendering would be: 'x [##foo]' (incorrect)\n    //\n    // 3. '[#foobar]' and insert ' ' between 'foo' and 'bar'\n    // desired rendering: '[#foo] bar'\n    // native rendering would be: '[#foo bar]' (incorrect)\n    //\n    // 4. '[#foo]' and delete '#' [won't use this beforeinput codepath though]\n    // desired rendering: 'foo'\n    // native rendering would be: '[foo]' (incorrect)\n    //\n    // 5. '[#foo]' and append 'b'\n    // desired rendering: '[#foob]'\n    // native rendering would be: '[#foob]'\n    // (native insertion here would be ok for decorators like simple spans,\n    // but not more complex decorators. To be safe, we need to prevent it.)\n    //\n    // It is safe to allow native insertion if and only if the full list of\n    // decorator ranges matches what we expect native insertion to give, and\n    // the range lengths have not changed. We don't need to compare the content\n    // because the only possible mutation to consider here is inserting plain\n    // text and decorators can't affect text content.\n    var oldBlockTree = editorState.getBlockTree(anchorKey);\n    var newBlockTree = newEditorState.getBlockTree(anchorKey);\n    mustPreventNative = oldBlockTree.size !== newBlockTree.size || oldBlockTree.zip(newBlockTree).some(function (_ref) {\n      var oldLeafSet = _ref[0],\n          newLeafSet = _ref[1];\n      // selectionStart is guaranteed to be selectionEnd here\n      var oldStart = oldLeafSet.get('start');\n      var adjustedStart = oldStart + (oldStart >= selectionStart ? chars.length : 0);\n      var oldEnd = oldLeafSet.get('end');\n      var adjustedEnd = oldEnd + (oldEnd >= selectionStart ? chars.length : 0);\n      var newStart = newLeafSet.get('start');\n      var newEnd = newLeafSet.get('end');\n      var newDecoratorKey = newLeafSet.get('decoratorKey');\n      return (// Different decorators\n        oldLeafSet.get('decoratorKey') !== newDecoratorKey || // Different number of inline styles\n        oldLeafSet.get('leaves').size !== newLeafSet.get('leaves').size || // Different effective decorator position\n        adjustedStart !== newStart || adjustedEnd !== newEnd || // Decorator already existed and its length changed\n        newDecoratorKey != null && newEnd - newStart !== oldEnd - oldStart\n      );\n    });\n  }\n\n  if (!mustPreventNative) {\n    mustPreventNative = mustPreventDefaultForCharacter(chars);\n  }\n\n  if (!mustPreventNative) {\n    mustPreventNative = nullthrows(newEditorState.getDirectionMap()).get(anchorKey) !== nullthrows(editorState.getDirectionMap()).get(anchorKey);\n  }\n\n  if (mustPreventNative) {\n    e.preventDefault();\n    newEditorState = EditorState.set(newEditorState, {\n      forceSelection: true\n    });\n    editor.update(newEditorState);\n    return;\n  } // We made it all the way! Let the browser do its thing and insert the char.\n\n\n  newEditorState = EditorState.set(newEditorState, {\n    nativelyRenderedContent: newEditorState.getCurrentContent()\n  }); // The native event is allowed to occur. To allow user onChange handlers to\n  // change the inserted text, we wait until the text is actually inserted\n  // before we actually update our state. That way when we rerender, the text\n  // we see in the DOM will already have been inserted properly.\n\n  editor._pendingStateFromBeforeInput = newEditorState;\n  setImmediate(function () {\n    if (editor._pendingStateFromBeforeInput !== undefined) {\n      editor.update(editor._pendingStateFromBeforeInput);\n      editor._pendingStateFromBeforeInput = undefined;\n    }\n  });\n}\n\nmodule.exports = editOnBeforeInput;"]},"metadata":{},"sourceType":"script"}