{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"coffeescript\", function (conf, parserConf) {\n    var ERRORCLASS = \"error\";\n\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n\n    var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\n    var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n    var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n    var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n    var wordOperators = wordRegexp([\"and\", \"or\", \"not\", \"is\", \"isnt\", \"in\", \"instanceof\", \"typeof\"]);\n    var indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\", \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\n    var commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\", \"do\", \"in\", \"of\", \"new\", \"return\", \"then\", \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n    var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n    indentKeywords = wordRegexp(indentKeywords);\n    var stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\n    var regexPrefixes = /^(\\/{3}|\\/)/;\n    var commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\n    var constants = wordRegexp(commonConstants); // Tokenizers\n\n    function tokenBase(stream, state) {\n      // Handle scope changes\n      if (stream.sol()) {\n        if (state.scope.align === null) state.scope.align = false;\n        var scopeOffset = state.scope.offset;\n\n        if (stream.eatSpace()) {\n          var lineOffset = stream.indentation();\n\n          if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n            return \"indent\";\n          } else if (lineOffset < scopeOffset) {\n            return \"dedent\";\n          }\n\n          return null;\n        } else {\n          if (scopeOffset > 0) {\n            dedent(stream, state);\n          }\n        }\n      }\n\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var ch = stream.peek(); // Handle docco title comment (single line)\n\n      if (stream.match(\"####\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      } // Handle multi line comments\n\n\n      if (stream.match(\"###\")) {\n        state.tokenize = longComment;\n        return state.tokenize(stream, state);\n      } // Single line comment\n\n\n      if (ch === \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      } // Handle number literals\n\n\n      if (stream.match(/^-?[0-9\\.]/, false)) {\n        var floatLiteral = false; // Floats\n\n        if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n          floatLiteral = true;\n        }\n\n        if (stream.match(/^-?\\d+\\.\\d*/)) {\n          floatLiteral = true;\n        }\n\n        if (stream.match(/^-?\\.\\d+/)) {\n          floatLiteral = true;\n        }\n\n        if (floatLiteral) {\n          // prevent from getting extra . on 1..\n          if (stream.peek() == \".\") {\n            stream.backUp(1);\n          }\n\n          return \"number\";\n        } // Integers\n\n\n        var intLiteral = false; // Hex\n\n        if (stream.match(/^-?0x[0-9a-f]+/i)) {\n          intLiteral = true;\n        } // Decimal\n\n\n        if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n          intLiteral = true;\n        } // Zero by itself with no other piece of number.\n\n\n        if (stream.match(/^-?0(?![\\dx])/i)) {\n          intLiteral = true;\n        }\n\n        if (intLiteral) {\n          return \"number\";\n        }\n      } // Handle strings\n\n\n      if (stream.match(stringPrefixes)) {\n        state.tokenize = tokenFactory(stream.current(), false, \"string\");\n        return state.tokenize(stream, state);\n      } // Handle regex literals\n\n\n      if (stream.match(regexPrefixes)) {\n        if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) {\n          // prevent highlight of division\n          state.tokenize = tokenFactory(stream.current(), true, \"string-2\");\n          return state.tokenize(stream, state);\n        } else {\n          stream.backUp(1);\n        }\n      } // Handle operators and delimiters\n\n\n      if (stream.match(operators) || stream.match(wordOperators)) {\n        return \"operator\";\n      }\n\n      if (stream.match(delimiters)) {\n        return \"punctuation\";\n      }\n\n      if (stream.match(constants)) {\n        return \"atom\";\n      }\n\n      if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n        return \"property\";\n      }\n\n      if (stream.match(keywords)) {\n        return \"keyword\";\n      }\n\n      if (stream.match(identifiers)) {\n        return \"variable\";\n      } // Handle non-detected items\n\n\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function tokenFactory(delimiter, singleline, outclass) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"\\/\\\\]/);\n\n          if (stream.eat(\"\\\\\")) {\n            stream.next();\n\n            if (singleline && stream.eol()) {\n              return outclass;\n            }\n          } else if (stream.match(delimiter)) {\n            state.tokenize = tokenBase;\n            return outclass;\n          } else {\n            stream.eat(/['\"\\/]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) {\n            outclass = ERRORCLASS;\n          } else {\n            state.tokenize = tokenBase;\n          }\n        }\n\n        return outclass;\n      };\n    }\n\n    function longComment(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^#]/);\n\n        if (stream.match(\"###\")) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        stream.eatWhile(\"#\");\n      }\n\n      return \"comment\";\n    }\n\n    function indent(stream, state, type) {\n      type = type || \"coffee\";\n      var offset = 0,\n          align = false,\n          alignOffset = null;\n\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (scope.type === \"coffee\" || scope.type == \"}\") {\n          offset = scope.offset + conf.indentUnit;\n          break;\n        }\n      }\n\n      if (type !== \"coffee\") {\n        align = null;\n        alignOffset = stream.column() + stream.current().length;\n      } else if (state.scope.align) {\n        state.scope.align = false;\n      }\n\n      state.scope = {\n        offset: offset,\n        type: type,\n        prev: state.scope,\n        align: align,\n        alignOffset: alignOffset\n      };\n    }\n\n    function dedent(stream, state) {\n      if (!state.scope.prev) return;\n\n      if (state.scope.type === \"coffee\") {\n        var _indent = stream.indentation();\n\n        var matched = false;\n\n        for (var scope = state.scope; scope; scope = scope.prev) {\n          if (_indent === scope.offset) {\n            matched = true;\n            break;\n          }\n        }\n\n        if (!matched) {\n          return true;\n        }\n\n        while (state.scope.prev && state.scope.offset !== _indent) {\n          state.scope = state.scope.prev;\n        }\n\n        return false;\n      } else {\n        state.scope = state.scope.prev;\n        return false;\n      }\n    }\n\n    function tokenLexer(stream, state) {\n      var style = state.tokenize(stream, state);\n      var current = stream.current(); // Handle scope changes.\n\n      if (current === \"return\") {\n        state.dedent = true;\n      }\n\n      if ((current === \"->\" || current === \"=>\") && stream.eol() || style === \"indent\") {\n        indent(stream, state);\n      }\n\n      var delimiter_index = \"[({\".indexOf(current);\n\n      if (delimiter_index !== -1) {\n        indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index + 1));\n      }\n\n      if (indentKeywords.exec(current)) {\n        indent(stream, state);\n      }\n\n      if (current == \"then\") {\n        dedent(stream, state);\n      }\n\n      if (style === \"dedent\") {\n        if (dedent(stream, state)) {\n          return ERRORCLASS;\n        }\n      }\n\n      delimiter_index = \"])}\".indexOf(current);\n\n      if (delimiter_index !== -1) {\n        while (state.scope.type == \"coffee\" && state.scope.prev) {\n          state.scope = state.scope.prev;\n        }\n\n        if (state.scope.type == current) state.scope = state.scope.prev;\n      }\n\n      if (state.dedent && stream.eol()) {\n        if (state.scope.type == \"coffee\" && state.scope.prev) state.scope = state.scope.prev;\n        state.dedent = false;\n      }\n\n      return style;\n    }\n\n    var external = {\n      startState: function startState(basecolumn) {\n        return {\n          tokenize: tokenBase,\n          scope: {\n            offset: basecolumn || 0,\n            type: \"coffee\",\n            prev: null,\n            align: false\n          },\n          prop: false,\n          dedent: 0\n        };\n      },\n      token: function token(stream, state) {\n        var fillAlign = state.scope.align === null && state.scope;\n        if (fillAlign && stream.sol()) fillAlign.align = false;\n        var style = tokenLexer(stream, state);\n\n        if (style && style != \"comment\") {\n          if (fillAlign) fillAlign.align = true;\n          state.prop = style == \"punctuation\" && stream.current() == \".\";\n        }\n\n        return style;\n      },\n      indent: function indent(state, text) {\n        if (state.tokenize != tokenBase) return 0;\n        var scope = state.scope;\n        var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n        if (closer) while (scope.type == \"coffee\" && scope.prev) {\n          scope = scope.prev;\n        }\n        var closes = closer && scope.type === text.charAt(0);\n        if (scope.align) return scope.alignOffset - (closes ? 1 : 0);else return (closes ? scope.prev : scope).offset;\n      },\n      lineComment: \"#\",\n      fold: \"indent\"\n    };\n    return external;\n  }); // IANA registered media type\n  // https://www.iana.org/assignments/media-types/\n\n  CodeMirror.defineMIME(\"application/vnd.coffeescript\", \"coffeescript\");\n  CodeMirror.defineMIME(\"text/x-coffeescript\", \"coffeescript\");\n  CodeMirror.defineMIME(\"text/coffeescript\", \"coffeescript\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/coffeescript/coffeescript.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","conf","parserConf","ERRORCLASS","wordRegexp","words","RegExp","join","operators","delimiters","identifiers","atProp","wordOperators","indentKeywords","commonKeywords","keywords","concat","stringPrefixes","regexPrefixes","commonConstants","constants","tokenBase","stream","state","sol","scope","align","scopeOffset","offset","eatSpace","lineOffset","indentation","type","dedent","ch","peek","match","skipToEnd","tokenize","longComment","floatLiteral","backUp","intLiteral","tokenFactory","current","prop","next","delimiter","singleline","outclass","eol","eatWhile","eat","singleLineStringErrors","indent","alignOffset","prev","indentUnit","column","length","_indent","matched","tokenLexer","style","delimiter_index","indexOf","slice","exec","external","startState","basecolumn","token","fillAlign","text","closer","charAt","closes","lineComment","fold","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Link to the project's GitHub page:\n * https://github.com/pickhardt/coffeescript-codemirror-mode\n */\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"coffeescript\", function(conf, parserConf) {\n  var ERRORCLASS = \"error\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var operators = /^(?:->|=>|\\+[+=]?|-[\\-=]?|\\*[\\*=]?|\\/[\\/=]?|[=!]=|<[><]?=?|>>?=?|%=?|&=?|\\|=?|\\^=?|\\~|!|\\?|(or|and|\\|\\||&&|\\?)=)/;\n  var delimiters = /^(?:[()\\[\\]{},:`=;]|\\.\\.?\\.?)/;\n  var identifiers = /^[_A-Za-z$][_A-Za-z$0-9]*/;\n  var atProp = /^@[_A-Za-z$][_A-Za-z$0-9]*/;\n\n  var wordOperators = wordRegexp([\"and\", \"or\", \"not\",\n                                  \"is\", \"isnt\", \"in\",\n                                  \"instanceof\", \"typeof\"]);\n  var indentKeywords = [\"for\", \"while\", \"loop\", \"if\", \"unless\", \"else\",\n                        \"switch\", \"try\", \"catch\", \"finally\", \"class\"];\n  var commonKeywords = [\"break\", \"by\", \"continue\", \"debugger\", \"delete\",\n                        \"do\", \"in\", \"of\", \"new\", \"return\", \"then\",\n                        \"this\", \"@\", \"throw\", \"when\", \"until\", \"extends\"];\n\n  var keywords = wordRegexp(indentKeywords.concat(commonKeywords));\n\n  indentKeywords = wordRegexp(indentKeywords);\n\n\n  var stringPrefixes = /^('{3}|\\\"{3}|['\\\"])/;\n  var regexPrefixes = /^(\\/{3}|\\/)/;\n  var commonConstants = [\"Infinity\", \"NaN\", \"undefined\", \"null\", \"true\", \"false\", \"on\", \"off\", \"yes\", \"no\"];\n  var constants = wordRegexp(commonConstants);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    // Handle scope changes\n    if (stream.sol()) {\n      if (state.scope.align === null) state.scope.align = false;\n      var scopeOffset = state.scope.offset;\n      if (stream.eatSpace()) {\n        var lineOffset = stream.indentation();\n        if (lineOffset > scopeOffset && state.scope.type == \"coffee\") {\n          return \"indent\";\n        } else if (lineOffset < scopeOffset) {\n          return \"dedent\";\n        }\n        return null;\n      } else {\n        if (scopeOffset > 0) {\n          dedent(stream, state);\n        }\n      }\n    }\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    var ch = stream.peek();\n\n    // Handle docco title comment (single line)\n    if (stream.match(\"####\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    // Handle multi line comments\n    if (stream.match(\"###\")) {\n      state.tokenize = longComment;\n      return state.tokenize(stream, state);\n    }\n\n    // Single line comment\n    if (ch === \"#\") {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    // Handle number literals\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      var floatLiteral = false;\n      // Floats\n      if (stream.match(/^-?\\d*\\.\\d+(e[\\+\\-]?\\d+)?/i)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\d+\\.\\d*/)) {\n        floatLiteral = true;\n      }\n      if (stream.match(/^-?\\.\\d+/)) {\n        floatLiteral = true;\n      }\n\n      if (floatLiteral) {\n        // prevent from getting extra . on 1..\n        if (stream.peek() == \".\"){\n          stream.backUp(1);\n        }\n        return \"number\";\n      }\n      // Integers\n      var intLiteral = false;\n      // Hex\n      if (stream.match(/^-?0x[0-9a-f]+/i)) {\n        intLiteral = true;\n      }\n      // Decimal\n      if (stream.match(/^-?[1-9]\\d*(e[\\+\\-]?\\d+)?/)) {\n        intLiteral = true;\n      }\n      // Zero by itself with no other piece of number.\n      if (stream.match(/^-?0(?![\\dx])/i)) {\n        intLiteral = true;\n      }\n      if (intLiteral) {\n        return \"number\";\n      }\n    }\n\n    // Handle strings\n    if (stream.match(stringPrefixes)) {\n      state.tokenize = tokenFactory(stream.current(), false, \"string\");\n      return state.tokenize(stream, state);\n    }\n    // Handle regex literals\n    if (stream.match(regexPrefixes)) {\n      if (stream.current() != \"/\" || stream.match(/^.*\\//, false)) { // prevent highlight of division\n        state.tokenize = tokenFactory(stream.current(), true, \"string-2\");\n        return state.tokenize(stream, state);\n      } else {\n        stream.backUp(1);\n      }\n    }\n\n\n\n    // Handle operators and delimiters\n    if (stream.match(operators) || stream.match(wordOperators)) {\n      return \"operator\";\n    }\n    if (stream.match(delimiters)) {\n      return \"punctuation\";\n    }\n\n    if (stream.match(constants)) {\n      return \"atom\";\n    }\n\n    if (stream.match(atProp) || state.prop && stream.match(identifiers)) {\n      return \"property\";\n    }\n\n    if (stream.match(keywords)) {\n      return \"keyword\";\n    }\n\n    if (stream.match(identifiers)) {\n      return \"variable\";\n    }\n\n    // Handle non-detected items\n    stream.next();\n    return ERRORCLASS;\n  }\n\n  function tokenFactory(delimiter, singleline, outclass) {\n    return function(stream, state) {\n      while (!stream.eol()) {\n        stream.eatWhile(/[^'\"\\/\\\\]/);\n        if (stream.eat(\"\\\\\")) {\n          stream.next();\n          if (singleline && stream.eol()) {\n            return outclass;\n          }\n        } else if (stream.match(delimiter)) {\n          state.tokenize = tokenBase;\n          return outclass;\n        } else {\n          stream.eat(/['\"\\/]/);\n        }\n      }\n      if (singleline) {\n        if (parserConf.singleLineStringErrors) {\n          outclass = ERRORCLASS;\n        } else {\n          state.tokenize = tokenBase;\n        }\n      }\n      return outclass;\n    };\n  }\n\n  function longComment(stream, state) {\n    while (!stream.eol()) {\n      stream.eatWhile(/[^#]/);\n      if (stream.match(\"###\")) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      stream.eatWhile(\"#\");\n    }\n    return \"comment\";\n  }\n\n  function indent(stream, state, type) {\n    type = type || \"coffee\";\n    var offset = 0, align = false, alignOffset = null;\n    for (var scope = state.scope; scope; scope = scope.prev) {\n      if (scope.type === \"coffee\" || scope.type == \"}\") {\n        offset = scope.offset + conf.indentUnit;\n        break;\n      }\n    }\n    if (type !== \"coffee\") {\n      align = null;\n      alignOffset = stream.column() + stream.current().length;\n    } else if (state.scope.align) {\n      state.scope.align = false;\n    }\n    state.scope = {\n      offset: offset,\n      type: type,\n      prev: state.scope,\n      align: align,\n      alignOffset: alignOffset\n    };\n  }\n\n  function dedent(stream, state) {\n    if (!state.scope.prev) return;\n    if (state.scope.type === \"coffee\") {\n      var _indent = stream.indentation();\n      var matched = false;\n      for (var scope = state.scope; scope; scope = scope.prev) {\n        if (_indent === scope.offset) {\n          matched = true;\n          break;\n        }\n      }\n      if (!matched) {\n        return true;\n      }\n      while (state.scope.prev && state.scope.offset !== _indent) {\n        state.scope = state.scope.prev;\n      }\n      return false;\n    } else {\n      state.scope = state.scope.prev;\n      return false;\n    }\n  }\n\n  function tokenLexer(stream, state) {\n    var style = state.tokenize(stream, state);\n    var current = stream.current();\n\n    // Handle scope changes.\n    if (current === \"return\") {\n      state.dedent = true;\n    }\n    if (((current === \"->\" || current === \"=>\") && stream.eol())\n        || style === \"indent\") {\n      indent(stream, state);\n    }\n    var delimiter_index = \"[({\".indexOf(current);\n    if (delimiter_index !== -1) {\n      indent(stream, state, \"])}\".slice(delimiter_index, delimiter_index+1));\n    }\n    if (indentKeywords.exec(current)){\n      indent(stream, state);\n    }\n    if (current == \"then\"){\n      dedent(stream, state);\n    }\n\n\n    if (style === \"dedent\") {\n      if (dedent(stream, state)) {\n        return ERRORCLASS;\n      }\n    }\n    delimiter_index = \"])}\".indexOf(current);\n    if (delimiter_index !== -1) {\n      while (state.scope.type == \"coffee\" && state.scope.prev)\n        state.scope = state.scope.prev;\n      if (state.scope.type == current)\n        state.scope = state.scope.prev;\n    }\n    if (state.dedent && stream.eol()) {\n      if (state.scope.type == \"coffee\" && state.scope.prev)\n        state.scope = state.scope.prev;\n      state.dedent = false;\n    }\n\n    return style;\n  }\n\n  var external = {\n    startState: function(basecolumn) {\n      return {\n        tokenize: tokenBase,\n        scope: {offset:basecolumn || 0, type:\"coffee\", prev: null, align: false},\n        prop: false,\n        dedent: 0\n      };\n    },\n\n    token: function(stream, state) {\n      var fillAlign = state.scope.align === null && state.scope;\n      if (fillAlign && stream.sol()) fillAlign.align = false;\n\n      var style = tokenLexer(stream, state);\n      if (style && style != \"comment\") {\n        if (fillAlign) fillAlign.align = true;\n        state.prop = style == \"punctuation\" && stream.current() == \".\"\n      }\n\n      return style;\n    },\n\n    indent: function(state, text) {\n      if (state.tokenize != tokenBase) return 0;\n      var scope = state.scope;\n      var closer = text && \"])}\".indexOf(text.charAt(0)) > -1;\n      if (closer) while (scope.type == \"coffee\" && scope.prev) scope = scope.prev;\n      var closes = closer && scope.type === text.charAt(0);\n      if (scope.align)\n        return scope.alignOffset - (closes ? 1 : 0);\n      else\n        return (closes ? scope.prev : scope).offset;\n    },\n\n    lineComment: \"#\",\n    fold: \"indent\"\n  };\n  return external;\n});\n\n// IANA registered media type\n// https://www.iana.org/assignments/media-types/\nCodeMirror.defineMIME(\"application/vnd.coffeescript\", \"coffeescript\");\n\nCodeMirror.defineMIME(\"text/x-coffeescript\", \"coffeescript\");\nCodeMirror.defineMIME(\"text/coffeescript\", \"coffeescript\");\n\n});\n"]},"metadata":{},"sourceType":"script"}