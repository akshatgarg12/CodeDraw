{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Yacas mode copyright (c) 2015 by Grzegorz Mazur\n// Loosely based on mathematica mode by Calin Barbat\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode('yacas', function (_config, _parserConfig) {\n    function words(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n      return obj;\n    }\n\n    var bodiedOps = words(\"Assert BackQuote D Defun Deriv For ForEach FromFile \" + \"FromString Function Integrate InverseTaylor Limit \" + \"LocalSymbols Macro MacroRule MacroRulePattern \" + \"NIntegrate Rule RulePattern Subst TD TExplicitSum \" + \"TSum Taylor Taylor1 Taylor2 Taylor3 ToFile \" + \"ToStdout ToString TraceRule Until While\"); // patterns\n\n    var pFloatForm = \"(?:(?:\\\\.\\\\d+|\\\\d+\\\\.\\\\d*|\\\\d+)(?:[eE][+-]?\\\\d+)?)\";\n    var pIdentifier = \"(?:[a-zA-Z\\\\$'][a-zA-Z0-9\\\\$']*)\"; // regular expressions\n\n    var reFloatForm = new RegExp(pFloatForm);\n    var reIdentifier = new RegExp(pIdentifier);\n    var rePattern = new RegExp(pIdentifier + \"?_\" + pIdentifier);\n    var reFunctionLike = new RegExp(pIdentifier + \"\\\\s*\\\\(\");\n\n    function tokenBase(stream, state) {\n      var ch; // get next character\n\n      ch = stream.next(); // string\n\n      if (ch === '\"') {\n        state.tokenize = tokenString;\n        return state.tokenize(stream, state);\n      } // comment\n\n\n      if (ch === '/') {\n        if (stream.eat('*')) {\n          state.tokenize = tokenComment;\n          return state.tokenize(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      } // go back one character\n\n\n      stream.backUp(1); // update scope info\n\n      var m = stream.match(/^(\\w+)\\s*\\(/, false);\n      if (m !== null && bodiedOps.hasOwnProperty(m[1])) state.scopes.push('bodied');\n      var scope = currentScope(state);\n      if (scope === 'bodied' && ch === '[') state.scopes.pop();\n      if (ch === '[' || ch === '{' || ch === '(') state.scopes.push(ch);\n      scope = currentScope(state);\n      if (scope === '[' && ch === ']' || scope === '{' && ch === '}' || scope === '(' && ch === ')') state.scopes.pop();\n\n      if (ch === ';') {\n        while (scope === 'bodied') {\n          state.scopes.pop();\n          scope = currentScope(state);\n        }\n      } // look for ordered rules\n\n\n      if (stream.match(/\\d+ *#/, true, false)) {\n        return 'qualifier';\n      } // look for numbers\n\n\n      if (stream.match(reFloatForm, true, false)) {\n        return 'number';\n      } // look for placeholders\n\n\n      if (stream.match(rePattern, true, false)) {\n        return 'variable-3';\n      } // match all braces separately\n\n\n      if (stream.match(/(?:\\[|\\]|{|}|\\(|\\))/, true, false)) {\n        return 'bracket';\n      } // literals looking like function calls\n\n\n      if (stream.match(reFunctionLike, true, false)) {\n        stream.backUp(1);\n        return 'variable';\n      } // all other identifiers\n\n\n      if (stream.match(reIdentifier, true, false)) {\n        return 'variable-2';\n      } // operators; note that operators like @@ or /; are matched separately for each symbol.\n\n\n      if (stream.match(/(?:\\\\|\\+|\\-|\\*|\\/|,|;|\\.|:|@|~|=|>|<|&|\\||_|`|'|\\^|\\?|!|%|#)/, true, false)) {\n        return 'operator';\n      } // everything else is an error\n\n\n      return 'error';\n    }\n\n    function tokenString(stream, state) {\n      var next,\n          end = false,\n          escaped = false;\n\n      while ((next = stream.next()) != null) {\n        if (next === '\"' && !escaped) {\n          end = true;\n          break;\n        }\n\n        escaped = !escaped && next === '\\\\';\n      }\n\n      if (end && !escaped) {\n        state.tokenize = tokenBase;\n      }\n\n      return 'string';\n    }\n\n    ;\n\n    function tokenComment(stream, state) {\n      var prev, next;\n\n      while ((next = stream.next()) != null) {\n        if (prev === '*' && next === '/') {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        prev = next;\n      }\n\n      return 'comment';\n    }\n\n    function currentScope(state) {\n      var scope = null;\n      if (state.scopes.length > 0) scope = state.scopes[state.scopes.length - 1];\n      return scope;\n    }\n\n    return {\n      startState: function () {\n        return {\n          tokenize: tokenBase,\n          scopes: []\n        };\n      },\n      token: function (stream, state) {\n        if (stream.eatSpace()) return null;\n        return state.tokenize(stream, state);\n      },\n      indent: function (state, textAfter) {\n        if (state.tokenize !== tokenBase && state.tokenize !== null) return CodeMirror.Pass;\n        var delta = 0;\n        if (textAfter === ']' || textAfter === '];' || textAfter === '}' || textAfter === '};' || textAfter === ');') delta = -1;\n        return (state.scopes.length + delta) * _config.indentUnit;\n      },\n      electricChars: \"{}[]();\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME('text/x-yacas', {\n    name: 'yacas'\n  });\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/yacas/yacas.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","_config","_parserConfig","words","str","obj","split","i","length","bodiedOps","pFloatForm","pIdentifier","reFloatForm","RegExp","reIdentifier","rePattern","reFunctionLike","tokenBase","stream","state","ch","next","tokenize","tokenString","eat","tokenComment","skipToEnd","backUp","m","match","hasOwnProperty","scopes","push","scope","currentScope","pop","end","escaped","prev","startState","token","eatSpace","indent","textAfter","Pass","delta","indentUnit","electricChars","blockCommentStart","blockCommentEnd","lineComment","defineMIME","name"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Yacas mode copyright (c) 2015 by Grzegorz Mazur\n// Loosely based on mathematica mode by Calin Barbat\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode('yacas', function(_config, _parserConfig) {\n\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  var bodiedOps = words(\"Assert BackQuote D Defun Deriv For ForEach FromFile \" +\n                        \"FromString Function Integrate InverseTaylor Limit \" +\n                        \"LocalSymbols Macro MacroRule MacroRulePattern \" +\n                        \"NIntegrate Rule RulePattern Subst TD TExplicitSum \" +\n                        \"TSum Taylor Taylor1 Taylor2 Taylor3 ToFile \" +\n                        \"ToStdout ToString TraceRule Until While\");\n\n  // patterns\n  var pFloatForm  = \"(?:(?:\\\\.\\\\d+|\\\\d+\\\\.\\\\d*|\\\\d+)(?:[eE][+-]?\\\\d+)?)\";\n  var pIdentifier = \"(?:[a-zA-Z\\\\$'][a-zA-Z0-9\\\\$']*)\";\n\n  // regular expressions\n  var reFloatForm    = new RegExp(pFloatForm);\n  var reIdentifier   = new RegExp(pIdentifier);\n  var rePattern      = new RegExp(pIdentifier + \"?_\" + pIdentifier);\n  var reFunctionLike = new RegExp(pIdentifier + \"\\\\s*\\\\(\");\n\n  function tokenBase(stream, state) {\n    var ch;\n\n    // get next character\n    ch = stream.next();\n\n    // string\n    if (ch === '\"') {\n      state.tokenize = tokenString;\n      return state.tokenize(stream, state);\n    }\n\n    // comment\n    if (ch === '/') {\n      if (stream.eat('*')) {\n        state.tokenize = tokenComment;\n        return state.tokenize(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n    }\n\n    // go back one character\n    stream.backUp(1);\n\n    // update scope info\n    var m = stream.match(/^(\\w+)\\s*\\(/, false);\n    if (m !== null && bodiedOps.hasOwnProperty(m[1]))\n      state.scopes.push('bodied');\n\n    var scope = currentScope(state);\n\n    if (scope === 'bodied' && ch === '[')\n      state.scopes.pop();\n\n    if (ch === '[' || ch === '{' || ch === '(')\n      state.scopes.push(ch);\n\n    scope = currentScope(state);\n\n    if (scope === '[' && ch === ']' ||\n        scope === '{' && ch === '}' ||\n        scope === '(' && ch === ')')\n      state.scopes.pop();\n\n    if (ch === ';') {\n      while (scope === 'bodied') {\n        state.scopes.pop();\n        scope = currentScope(state);\n      }\n    }\n\n    // look for ordered rules\n    if (stream.match(/\\d+ *#/, true, false)) {\n      return 'qualifier';\n    }\n\n    // look for numbers\n    if (stream.match(reFloatForm, true, false)) {\n      return 'number';\n    }\n\n    // look for placeholders\n    if (stream.match(rePattern, true, false)) {\n      return 'variable-3';\n    }\n\n    // match all braces separately\n    if (stream.match(/(?:\\[|\\]|{|}|\\(|\\))/, true, false)) {\n      return 'bracket';\n    }\n\n    // literals looking like function calls\n    if (stream.match(reFunctionLike, true, false)) {\n      stream.backUp(1);\n      return 'variable';\n    }\n\n    // all other identifiers\n    if (stream.match(reIdentifier, true, false)) {\n      return 'variable-2';\n    }\n\n    // operators; note that operators like @@ or /; are matched separately for each symbol.\n    if (stream.match(/(?:\\\\|\\+|\\-|\\*|\\/|,|;|\\.|:|@|~|=|>|<|&|\\||_|`|'|\\^|\\?|!|%|#)/, true, false)) {\n      return 'operator';\n    }\n\n    // everything else is an error\n    return 'error';\n  }\n\n  function tokenString(stream, state) {\n    var next, end = false, escaped = false;\n    while ((next = stream.next()) != null) {\n      if (next === '\"' && !escaped) {\n        end = true;\n        break;\n      }\n      escaped = !escaped && next === '\\\\';\n    }\n    if (end && !escaped) {\n      state.tokenize = tokenBase;\n    }\n    return 'string';\n  };\n\n  function tokenComment(stream, state) {\n    var prev, next;\n    while((next = stream.next()) != null) {\n      if (prev === '*' && next === '/') {\n        state.tokenize = tokenBase;\n        break;\n      }\n      prev = next;\n    }\n    return 'comment';\n  }\n\n  function currentScope(state) {\n    var scope = null;\n    if (state.scopes.length > 0)\n      scope = state.scopes[state.scopes.length - 1];\n    return scope;\n  }\n\n  return {\n    startState: function() {\n      return {\n        tokenize: tokenBase,\n        scopes: []\n      };\n    },\n    token: function(stream, state) {\n      if (stream.eatSpace()) return null;\n      return state.tokenize(stream, state);\n    },\n    indent: function(state, textAfter) {\n      if (state.tokenize !== tokenBase && state.tokenize !== null)\n        return CodeMirror.Pass;\n\n      var delta = 0;\n      if (textAfter === ']' || textAfter === '];' ||\n          textAfter === '}' || textAfter === '};' ||\n          textAfter === ');')\n        delta = -1;\n\n      return (state.scopes.length + delta) * _config.indentUnit;\n    },\n    electricChars: \"{}[]();\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\nCodeMirror.defineMIME('text/x-yacas', {\n  name: 'yacas'\n});\n\n});\n"]},"metadata":{},"sourceType":"script"}