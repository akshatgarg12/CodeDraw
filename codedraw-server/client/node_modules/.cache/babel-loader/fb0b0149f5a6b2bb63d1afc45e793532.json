{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"vb\", function (conf, parserConf) {\n    var ERRORCLASS = 'error';\n\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\", \"i\");\n    }\n\n    var singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/%&\\\\\\\\|\\\\^~<>!]\");\n    var singleDelimiters = new RegExp('^[\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}@,:`=;\\\\.]');\n    var doubleOperators = new RegExp(\"^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\\\*\\\\*))\");\n    var doubleDelimiters = new RegExp(\"^((\\\\+=)|(\\\\-=)|(\\\\*=)|(%=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\n    var tripleDelimiters = new RegExp(\"^((//=)|(>>=)|(<<=)|(\\\\*\\\\*=))\");\n    var identifiers = new RegExp(\"^[_A-Za-z][_A-Za-z0-9]*\");\n    var openingKeywords = ['class', 'module', 'sub', 'enum', 'select', 'while', 'if', 'function', 'get', 'set', 'property', 'try', 'structure', 'synclock', 'using', 'with'];\n    var middleKeywords = ['else', 'elseif', 'case', 'catch', 'finally'];\n    var endKeywords = ['next', 'loop'];\n    var operatorKeywords = ['and', \"andalso\", 'or', 'orelse', 'xor', 'in', 'not', 'is', 'isnot', 'like'];\n    var wordOperators = wordRegexp(operatorKeywords);\n    var commonKeywords = [\"#const\", \"#else\", \"#elseif\", \"#end\", \"#if\", \"#region\", \"addhandler\", \"addressof\", \"alias\", \"as\", \"byref\", \"byval\", \"cbool\", \"cbyte\", \"cchar\", \"cdate\", \"cdbl\", \"cdec\", \"cint\", \"clng\", \"cobj\", \"compare\", \"const\", \"continue\", \"csbyte\", \"cshort\", \"csng\", \"cstr\", \"cuint\", \"culng\", \"cushort\", \"declare\", \"default\", \"delegate\", \"dim\", \"directcast\", \"each\", \"erase\", \"error\", \"event\", \"exit\", \"explicit\", \"false\", \"for\", \"friend\", \"gettype\", \"goto\", \"handles\", \"implements\", \"imports\", \"infer\", \"inherits\", \"interface\", \"isfalse\", \"istrue\", \"lib\", \"me\", \"mod\", \"mustinherit\", \"mustoverride\", \"my\", \"mybase\", \"myclass\", \"namespace\", \"narrowing\", \"new\", \"nothing\", \"notinheritable\", \"notoverridable\", \"of\", \"off\", \"on\", \"operator\", \"option\", \"optional\", \"out\", \"overloads\", \"overridable\", \"overrides\", \"paramarray\", \"partial\", \"private\", \"protected\", \"public\", \"raiseevent\", \"readonly\", \"redim\", \"removehandler\", \"resume\", \"return\", \"shadows\", \"shared\", \"static\", \"step\", \"stop\", \"strict\", \"then\", \"throw\", \"to\", \"true\", \"trycast\", \"typeof\", \"until\", \"until\", \"when\", \"widening\", \"withevents\", \"writeonly\"];\n    var commontypes = ['object', 'boolean', 'char', 'string', 'byte', 'sbyte', 'short', 'ushort', 'int16', 'uint16', 'integer', 'uinteger', 'int32', 'uint32', 'long', 'ulong', 'int64', 'uint64', 'decimal', 'single', 'double', 'float', 'date', 'datetime', 'intptr', 'uintptr'];\n    var keywords = wordRegexp(commonKeywords);\n    var types = wordRegexp(commontypes);\n    var stringPrefixes = '\"';\n    var opening = wordRegexp(openingKeywords);\n    var middle = wordRegexp(middleKeywords);\n    var closing = wordRegexp(endKeywords);\n    var doubleClosing = wordRegexp(['end']);\n    var doOpening = wordRegexp(['do']);\n    var indentInfo = null;\n    CodeMirror.registerHelper(\"hintWords\", \"vb\", openingKeywords.concat(middleKeywords).concat(endKeywords).concat(operatorKeywords).concat(commonKeywords).concat(commontypes));\n\n    function indent(_stream, state) {\n      state.currentIndent++;\n    }\n\n    function dedent(_stream, state) {\n      state.currentIndent--;\n    } // tokenizers\n\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var ch = stream.peek(); // Handle Comments\n\n      if (ch === \"'\") {\n        stream.skipToEnd();\n        return 'comment';\n      } // Handle Number Literals\n\n\n      if (stream.match(/^((&H)|(&O))?[0-9\\.a-f]/i, false)) {\n        var floatLiteral = false; // Floats\n\n        if (stream.match(/^\\d*\\.\\d+F?/i)) {\n          floatLiteral = true;\n        } else if (stream.match(/^\\d+\\.\\d*F?/)) {\n          floatLiteral = true;\n        } else if (stream.match(/^\\.\\d+F?/)) {\n          floatLiteral = true;\n        }\n\n        if (floatLiteral) {\n          // Float literals may be \"imaginary\"\n          stream.eat(/J/i);\n          return 'number';\n        } // Integers\n\n\n        var intLiteral = false; // Hex\n\n        if (stream.match(/^&H[0-9a-f]+/i)) {\n          intLiteral = true;\n        } // Octal\n        else if (stream.match(/^&O[0-7]+/i)) {\n            intLiteral = true;\n          } // Decimal\n          else if (stream.match(/^[1-9]\\d*F?/)) {\n              // Decimal literals may be \"imaginary\"\n              stream.eat(/J/i); // TODO - Can you have imaginary longs?\n\n              intLiteral = true;\n            } // Zero by itself with no other piece of number.\n            else if (stream.match(/^0(?![\\dx])/i)) {\n                intLiteral = true;\n              }\n\n        if (intLiteral) {\n          // Integer literals may be \"long\"\n          stream.eat(/L/i);\n          return 'number';\n        }\n      } // Handle Strings\n\n\n      if (stream.match(stringPrefixes)) {\n        state.tokenize = tokenStringFactory(stream.current());\n        return state.tokenize(stream, state);\n      } // Handle operators and Delimiters\n\n\n      if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {\n        return null;\n      }\n\n      if (stream.match(doubleOperators) || stream.match(singleOperators) || stream.match(wordOperators)) {\n        return 'operator';\n      }\n\n      if (stream.match(singleDelimiters)) {\n        return null;\n      }\n\n      if (stream.match(doOpening)) {\n        indent(stream, state);\n        state.doInCurrentLine = true;\n        return 'keyword';\n      }\n\n      if (stream.match(opening)) {\n        if (!state.doInCurrentLine) indent(stream, state);else state.doInCurrentLine = false;\n        return 'keyword';\n      }\n\n      if (stream.match(middle)) {\n        return 'keyword';\n      }\n\n      if (stream.match(doubleClosing)) {\n        dedent(stream, state);\n        dedent(stream, state);\n        return 'keyword';\n      }\n\n      if (stream.match(closing)) {\n        dedent(stream, state);\n        return 'keyword';\n      }\n\n      if (stream.match(types)) {\n        return 'keyword';\n      }\n\n      if (stream.match(keywords)) {\n        return 'keyword';\n      }\n\n      if (stream.match(identifiers)) {\n        return 'variable';\n      } // Handle non-detected items\n\n\n      stream.next();\n      return ERRORCLASS;\n    }\n\n    function tokenStringFactory(delimiter) {\n      var singleline = delimiter.length == 1;\n      var OUTCLASS = 'string';\n      return function (stream, state) {\n        while (!stream.eol()) {\n          stream.eatWhile(/[^'\"]/);\n\n          if (stream.match(delimiter)) {\n            state.tokenize = tokenBase;\n            return OUTCLASS;\n          } else {\n            stream.eat(/['\"]/);\n          }\n        }\n\n        if (singleline) {\n          if (parserConf.singleLineStringErrors) {\n            return ERRORCLASS;\n          } else {\n            state.tokenize = tokenBase;\n          }\n        }\n\n        return OUTCLASS;\n      };\n    }\n\n    function tokenLexer(stream, state) {\n      var style = state.tokenize(stream, state);\n      var current = stream.current(); // Handle '.' connected identifiers\n\n      if (current === '.') {\n        style = state.tokenize(stream, state);\n\n        if (style === 'variable') {\n          return 'variable';\n        } else {\n          return ERRORCLASS;\n        }\n      }\n\n      var delimiter_index = '[({'.indexOf(current);\n\n      if (delimiter_index !== -1) {\n        indent(stream, state);\n      }\n\n      if (indentInfo === 'dedent') {\n        if (dedent(stream, state)) {\n          return ERRORCLASS;\n        }\n      }\n\n      delimiter_index = '])}'.indexOf(current);\n\n      if (delimiter_index !== -1) {\n        if (dedent(stream, state)) {\n          return ERRORCLASS;\n        }\n      }\n\n      return style;\n    }\n\n    var external = {\n      electricChars: \"dDpPtTfFeE \",\n      startState: function startState() {\n        return {\n          tokenize: tokenBase,\n          lastToken: null,\n          currentIndent: 0,\n          nextLineIndent: 0,\n          doInCurrentLine: false\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          state.currentIndent += state.nextLineIndent;\n          state.nextLineIndent = 0;\n          state.doInCurrentLine = 0;\n        }\n\n        var style = tokenLexer(stream, state);\n        state.lastToken = {\n          style: style,\n          content: stream.current()\n        };\n        return style;\n      },\n      indent: function indent(state, textAfter) {\n        var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n        if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit * (state.currentIndent - 1);\n        if (state.currentIndent < 0) return 0;\n        return state.currentIndent * conf.indentUnit;\n      },\n      lineComment: \"'\"\n    };\n    return external;\n  });\n  CodeMirror.defineMIME(\"text/x-vb\", \"vb\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/vb/vb.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","conf","parserConf","ERRORCLASS","wordRegexp","words","RegExp","join","singleOperators","singleDelimiters","doubleOperators","doubleDelimiters","tripleDelimiters","identifiers","openingKeywords","middleKeywords","endKeywords","operatorKeywords","wordOperators","commonKeywords","commontypes","keywords","types","stringPrefixes","opening","middle","closing","doubleClosing","doOpening","indentInfo","registerHelper","concat","indent","_stream","state","currentIndent","dedent","tokenBase","stream","eatSpace","ch","peek","skipToEnd","match","floatLiteral","eat","intLiteral","tokenize","tokenStringFactory","current","doInCurrentLine","next","delimiter","singleline","length","OUTCLASS","eol","eatWhile","singleLineStringErrors","tokenLexer","style","delimiter_index","indexOf","external","electricChars","startState","lastToken","nextLineIndent","token","sol","content","textAfter","trueText","replace","indentUnit","lineComment","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"vb\", function(conf, parserConf) {\n    var ERRORCLASS = 'error';\n\n    function wordRegexp(words) {\n        return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\", \"i\");\n    }\n\n    var singleOperators = new RegExp(\"^[\\\\+\\\\-\\\\*/%&\\\\\\\\|\\\\^~<>!]\");\n    var singleDelimiters = new RegExp('^[\\\\(\\\\)\\\\[\\\\]\\\\{\\\\}@,:`=;\\\\.]');\n    var doubleOperators = new RegExp(\"^((==)|(<>)|(<=)|(>=)|(<>)|(<<)|(>>)|(//)|(\\\\*\\\\*))\");\n    var doubleDelimiters = new RegExp(\"^((\\\\+=)|(\\\\-=)|(\\\\*=)|(%=)|(/=)|(&=)|(\\\\|=)|(\\\\^=))\");\n    var tripleDelimiters = new RegExp(\"^((//=)|(>>=)|(<<=)|(\\\\*\\\\*=))\");\n    var identifiers = new RegExp(\"^[_A-Za-z][_A-Za-z0-9]*\");\n\n    var openingKeywords = ['class','module', 'sub','enum','select','while','if','function', 'get','set','property', 'try', 'structure', 'synclock', 'using', 'with'];\n    var middleKeywords = ['else','elseif','case', 'catch', 'finally'];\n    var endKeywords = ['next','loop'];\n\n    var operatorKeywords = ['and', \"andalso\", 'or', 'orelse', 'xor', 'in', 'not', 'is', 'isnot', 'like'];\n    var wordOperators = wordRegexp(operatorKeywords);\n\n    var commonKeywords = [\"#const\", \"#else\", \"#elseif\", \"#end\", \"#if\", \"#region\", \"addhandler\", \"addressof\", \"alias\", \"as\", \"byref\", \"byval\", \"cbool\", \"cbyte\", \"cchar\", \"cdate\", \"cdbl\", \"cdec\", \"cint\", \"clng\", \"cobj\", \"compare\", \"const\", \"continue\", \"csbyte\", \"cshort\", \"csng\", \"cstr\", \"cuint\", \"culng\", \"cushort\", \"declare\", \"default\", \"delegate\", \"dim\", \"directcast\", \"each\", \"erase\", \"error\", \"event\", \"exit\", \"explicit\", \"false\", \"for\", \"friend\", \"gettype\", \"goto\", \"handles\", \"implements\", \"imports\", \"infer\", \"inherits\", \"interface\", \"isfalse\", \"istrue\", \"lib\", \"me\", \"mod\", \"mustinherit\", \"mustoverride\", \"my\", \"mybase\", \"myclass\", \"namespace\", \"narrowing\", \"new\", \"nothing\", \"notinheritable\", \"notoverridable\", \"of\", \"off\", \"on\", \"operator\", \"option\", \"optional\", \"out\", \"overloads\", \"overridable\", \"overrides\", \"paramarray\", \"partial\", \"private\", \"protected\", \"public\", \"raiseevent\", \"readonly\", \"redim\", \"removehandler\", \"resume\", \"return\", \"shadows\", \"shared\", \"static\", \"step\", \"stop\", \"strict\", \"then\", \"throw\", \"to\", \"true\", \"trycast\", \"typeof\", \"until\", \"until\", \"when\", \"widening\", \"withevents\", \"writeonly\"];\n\n    var commontypes = ['object', 'boolean', 'char', 'string', 'byte', 'sbyte', 'short', 'ushort', 'int16', 'uint16', 'integer', 'uinteger', 'int32', 'uint32', 'long', 'ulong', 'int64', 'uint64', 'decimal', 'single', 'double', 'float', 'date', 'datetime', 'intptr', 'uintptr'];\n\n    var keywords = wordRegexp(commonKeywords);\n    var types = wordRegexp(commontypes);\n    var stringPrefixes = '\"';\n\n    var opening = wordRegexp(openingKeywords);\n    var middle = wordRegexp(middleKeywords);\n    var closing = wordRegexp(endKeywords);\n    var doubleClosing = wordRegexp(['end']);\n    var doOpening = wordRegexp(['do']);\n\n    var indentInfo = null;\n\n    CodeMirror.registerHelper(\"hintWords\", \"vb\", openingKeywords.concat(middleKeywords).concat(endKeywords)\n                                .concat(operatorKeywords).concat(commonKeywords).concat(commontypes));\n\n    function indent(_stream, state) {\n      state.currentIndent++;\n    }\n\n    function dedent(_stream, state) {\n      state.currentIndent--;\n    }\n    // tokenizers\n    function tokenBase(stream, state) {\n        if (stream.eatSpace()) {\n            return null;\n        }\n\n        var ch = stream.peek();\n\n        // Handle Comments\n        if (ch === \"'\") {\n            stream.skipToEnd();\n            return 'comment';\n        }\n\n\n        // Handle Number Literals\n        if (stream.match(/^((&H)|(&O))?[0-9\\.a-f]/i, false)) {\n            var floatLiteral = false;\n            // Floats\n            if (stream.match(/^\\d*\\.\\d+F?/i)) { floatLiteral = true; }\n            else if (stream.match(/^\\d+\\.\\d*F?/)) { floatLiteral = true; }\n            else if (stream.match(/^\\.\\d+F?/)) { floatLiteral = true; }\n\n            if (floatLiteral) {\n                // Float literals may be \"imaginary\"\n                stream.eat(/J/i);\n                return 'number';\n            }\n            // Integers\n            var intLiteral = false;\n            // Hex\n            if (stream.match(/^&H[0-9a-f]+/i)) { intLiteral = true; }\n            // Octal\n            else if (stream.match(/^&O[0-7]+/i)) { intLiteral = true; }\n            // Decimal\n            else if (stream.match(/^[1-9]\\d*F?/)) {\n                // Decimal literals may be \"imaginary\"\n                stream.eat(/J/i);\n                // TODO - Can you have imaginary longs?\n                intLiteral = true;\n            }\n            // Zero by itself with no other piece of number.\n            else if (stream.match(/^0(?![\\dx])/i)) { intLiteral = true; }\n            if (intLiteral) {\n                // Integer literals may be \"long\"\n                stream.eat(/L/i);\n                return 'number';\n            }\n        }\n\n        // Handle Strings\n        if (stream.match(stringPrefixes)) {\n            state.tokenize = tokenStringFactory(stream.current());\n            return state.tokenize(stream, state);\n        }\n\n        // Handle operators and Delimiters\n        if (stream.match(tripleDelimiters) || stream.match(doubleDelimiters)) {\n            return null;\n        }\n        if (stream.match(doubleOperators)\n            || stream.match(singleOperators)\n            || stream.match(wordOperators)) {\n            return 'operator';\n        }\n        if (stream.match(singleDelimiters)) {\n            return null;\n        }\n        if (stream.match(doOpening)) {\n            indent(stream,state);\n            state.doInCurrentLine = true;\n            return 'keyword';\n        }\n        if (stream.match(opening)) {\n            if (! state.doInCurrentLine)\n              indent(stream,state);\n            else\n              state.doInCurrentLine = false;\n            return 'keyword';\n        }\n        if (stream.match(middle)) {\n            return 'keyword';\n        }\n\n        if (stream.match(doubleClosing)) {\n            dedent(stream,state);\n            dedent(stream,state);\n            return 'keyword';\n        }\n        if (stream.match(closing)) {\n            dedent(stream,state);\n            return 'keyword';\n        }\n\n        if (stream.match(types)) {\n            return 'keyword';\n        }\n\n        if (stream.match(keywords)) {\n            return 'keyword';\n        }\n\n        if (stream.match(identifiers)) {\n            return 'variable';\n        }\n\n        // Handle non-detected items\n        stream.next();\n        return ERRORCLASS;\n    }\n\n    function tokenStringFactory(delimiter) {\n        var singleline = delimiter.length == 1;\n        var OUTCLASS = 'string';\n\n        return function(stream, state) {\n            while (!stream.eol()) {\n                stream.eatWhile(/[^'\"]/);\n                if (stream.match(delimiter)) {\n                    state.tokenize = tokenBase;\n                    return OUTCLASS;\n                } else {\n                    stream.eat(/['\"]/);\n                }\n            }\n            if (singleline) {\n                if (parserConf.singleLineStringErrors) {\n                    return ERRORCLASS;\n                } else {\n                    state.tokenize = tokenBase;\n                }\n            }\n            return OUTCLASS;\n        };\n    }\n\n\n    function tokenLexer(stream, state) {\n        var style = state.tokenize(stream, state);\n        var current = stream.current();\n\n        // Handle '.' connected identifiers\n        if (current === '.') {\n            style = state.tokenize(stream, state);\n            if (style === 'variable') {\n                return 'variable';\n            } else {\n                return ERRORCLASS;\n            }\n        }\n\n\n        var delimiter_index = '[({'.indexOf(current);\n        if (delimiter_index !== -1) {\n            indent(stream, state );\n        }\n        if (indentInfo === 'dedent') {\n            if (dedent(stream, state)) {\n                return ERRORCLASS;\n            }\n        }\n        delimiter_index = '])}'.indexOf(current);\n        if (delimiter_index !== -1) {\n            if (dedent(stream, state)) {\n                return ERRORCLASS;\n            }\n        }\n\n        return style;\n    }\n\n    var external = {\n        electricChars:\"dDpPtTfFeE \",\n        startState: function() {\n            return {\n              tokenize: tokenBase,\n              lastToken: null,\n              currentIndent: 0,\n              nextLineIndent: 0,\n              doInCurrentLine: false\n\n\n          };\n        },\n\n        token: function(stream, state) {\n            if (stream.sol()) {\n              state.currentIndent += state.nextLineIndent;\n              state.nextLineIndent = 0;\n              state.doInCurrentLine = 0;\n            }\n            var style = tokenLexer(stream, state);\n\n            state.lastToken = {style:style, content: stream.current()};\n\n\n\n            return style;\n        },\n\n        indent: function(state, textAfter) {\n            var trueText = textAfter.replace(/^\\s+|\\s+$/g, '') ;\n            if (trueText.match(closing) || trueText.match(doubleClosing) || trueText.match(middle)) return conf.indentUnit*(state.currentIndent-1);\n            if(state.currentIndent < 0) return 0;\n            return state.currentIndent * conf.indentUnit;\n        },\n\n        lineComment: \"'\"\n    };\n    return external;\n});\n\nCodeMirror.defineMIME(\"text/x-vb\", \"vb\");\n\n});\n"]},"metadata":{},"sourceType":"script"}