{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n// Factor syntax highlight - simple mode\n//\n// by Dimage Sapelkin (https://github.com/kerabromsmu)\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/simple\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/simple\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode(\"factor\", {\n    // The start state contains the rules that are intially used\n    start: [// comments\n    {\n      regex: /#?!.*/,\n      token: \"comment\"\n    }, // strings \"\"\", multiline --> state\n    {\n      regex: /\"\"\"/,\n      token: \"string\",\n      next: \"string3\"\n    }, {\n      regex: /(STRING:)(\\s)/,\n      token: [\"keyword\", null],\n      next: \"string2\"\n    }, {\n      regex: /\\S*?\"/,\n      token: \"string\",\n      next: \"string\"\n    }, // numbers: dec, hex, unicode, bin, fractional, complex\n    {\n      regex: /(?:0x[\\d,a-f]+)|(?:0o[0-7]+)|(?:0b[0,1]+)|(?:\\-?\\d+.?\\d*)(?=\\s)/,\n      token: \"number\"\n    }, //{regex: /[+-]?/} //fractional\n    // definition: defining word, defined word, etc\n    {\n      regex: /((?:GENERIC)|\\:?\\:)(\\s+)(\\S+)(\\s+)(\\()/,\n      token: [\"keyword\", null, \"def\", null, \"bracket\"],\n      next: \"stack\"\n    }, // method definition: defining word, type, defined word, etc\n    {\n      regex: /(M\\:)(\\s+)(\\S+)(\\s+)(\\S+)/,\n      token: [\"keyword\", null, \"def\", null, \"tag\"]\n    }, // vocabulary using --> state\n    {\n      regex: /USING\\:/,\n      token: \"keyword\",\n      next: \"vocabulary\"\n    }, // vocabulary definition/use\n    {\n      regex: /(USE\\:|IN\\:)(\\s+)(\\S+)(?=\\s|$)/,\n      token: [\"keyword\", null, \"tag\"]\n    }, // definition: a defining word, defined word\n    {\n      regex: /(\\S+\\:)(\\s+)(\\S+)(?=\\s|$)/,\n      token: [\"keyword\", null, \"def\"]\n    }, // \"keywords\", incl. ; t f . [ ] { } defining words\n    {\n      regex: /(?:;|\\\\|t|f|if|loop|while|until|do|PRIVATE>|<PRIVATE|\\.|\\S*\\[|\\]|\\S*\\{|\\})(?=\\s|$)/,\n      token: \"keyword\"\n    }, // <constructors> and the like\n    {\n      regex: /\\S+[\\)>\\.\\*\\?]+(?=\\s|$)/,\n      token: \"builtin\"\n    }, {\n      regex: /[\\)><]+\\S+(?=\\s|$)/,\n      token: \"builtin\"\n    }, // operators\n    {\n      regex: /(?:[\\+\\-\\=\\/\\*<>])(?=\\s|$)/,\n      token: \"keyword\"\n    }, // any id (?)\n    {\n      regex: /\\S+/,\n      token: \"variable\"\n    }, {\n      regex: /\\s+|./,\n      token: null\n    }],\n    vocabulary: [{\n      regex: /;/,\n      token: \"keyword\",\n      next: \"start\"\n    }, {\n      regex: /\\S+/,\n      token: \"tag\"\n    }, {\n      regex: /\\s+|./,\n      token: null\n    }],\n    string: [{\n      regex: /(?:[^\\\\]|\\\\.)*?\"/,\n      token: \"string\",\n      next: \"start\"\n    }, {\n      regex: /.*/,\n      token: \"string\"\n    }],\n    string2: [{\n      regex: /^;/,\n      token: \"keyword\",\n      next: \"start\"\n    }, {\n      regex: /.*/,\n      token: \"string\"\n    }],\n    string3: [{\n      regex: /(?:[^\\\\]|\\\\.)*?\"\"\"/,\n      token: \"string\",\n      next: \"start\"\n    }, {\n      regex: /.*/,\n      token: \"string\"\n    }],\n    stack: [{\n      regex: /\\)/,\n      token: \"bracket\",\n      next: \"start\"\n    }, {\n      regex: /--/,\n      token: \"bracket\"\n    }, {\n      regex: /\\S+/,\n      token: \"meta\"\n    }, {\n      regex: /\\s+|./,\n      token: null\n    }],\n    // The meta property contains global information about the mode. It\n    // can contain properties like lineComment, which are supported by\n    // all modes, and also directives like dontIndentStates, which are\n    // specific to simple modes.\n    meta: {\n      dontIndentStates: [\"start\", \"vocabulary\", \"string\", \"string3\", \"stack\"],\n      lineComment: [\"!\", \"#!\"]\n    }\n  });\n  CodeMirror.defineMIME(\"text/x-factor\", \"factor\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/factor/factor.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineSimpleMode","start","regex","token","next","vocabulary","string","string2","string3","stack","meta","dontIndentStates","lineComment","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n// Factor syntax highlight - simple mode\n//\n// by Dimage Sapelkin (https://github.com/kerabromsmu)\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../../addon/mode/simple\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../../addon/mode/simple\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineSimpleMode(\"factor\", {\n    // The start state contains the rules that are intially used\n    start: [\n      // comments\n      {regex: /#?!.*/, token: \"comment\"},\n      // strings \"\"\", multiline --> state\n      {regex: /\"\"\"/, token: \"string\", next: \"string3\"},\n      {regex: /(STRING:)(\\s)/, token: [\"keyword\", null], next: \"string2\"},\n      {regex: /\\S*?\"/, token: \"string\", next: \"string\"},\n      // numbers: dec, hex, unicode, bin, fractional, complex\n      {regex: /(?:0x[\\d,a-f]+)|(?:0o[0-7]+)|(?:0b[0,1]+)|(?:\\-?\\d+.?\\d*)(?=\\s)/, token: \"number\"},\n      //{regex: /[+-]?/} //fractional\n      // definition: defining word, defined word, etc\n      {regex: /((?:GENERIC)|\\:?\\:)(\\s+)(\\S+)(\\s+)(\\()/, token: [\"keyword\", null, \"def\", null, \"bracket\"], next: \"stack\"},\n      // method definition: defining word, type, defined word, etc\n      {regex: /(M\\:)(\\s+)(\\S+)(\\s+)(\\S+)/, token: [\"keyword\", null, \"def\", null, \"tag\"]},\n      // vocabulary using --> state\n      {regex: /USING\\:/, token: \"keyword\", next: \"vocabulary\"},\n      // vocabulary definition/use\n      {regex: /(USE\\:|IN\\:)(\\s+)(\\S+)(?=\\s|$)/, token: [\"keyword\", null, \"tag\"]},\n      // definition: a defining word, defined word\n      {regex: /(\\S+\\:)(\\s+)(\\S+)(?=\\s|$)/, token: [\"keyword\", null, \"def\"]},\n      // \"keywords\", incl. ; t f . [ ] { } defining words\n      {regex: /(?:;|\\\\|t|f|if|loop|while|until|do|PRIVATE>|<PRIVATE|\\.|\\S*\\[|\\]|\\S*\\{|\\})(?=\\s|$)/, token: \"keyword\"},\n      // <constructors> and the like\n      {regex: /\\S+[\\)>\\.\\*\\?]+(?=\\s|$)/, token: \"builtin\"},\n      {regex: /[\\)><]+\\S+(?=\\s|$)/, token: \"builtin\"},\n      // operators\n      {regex: /(?:[\\+\\-\\=\\/\\*<>])(?=\\s|$)/, token: \"keyword\"},\n      // any id (?)\n      {regex: /\\S+/, token: \"variable\"},\n      {regex: /\\s+|./, token: null}\n    ],\n    vocabulary: [\n      {regex: /;/, token: \"keyword\", next: \"start\"},\n      {regex: /\\S+/, token: \"tag\"},\n      {regex: /\\s+|./, token: null}\n    ],\n    string: [\n      {regex: /(?:[^\\\\]|\\\\.)*?\"/, token: \"string\", next: \"start\"},\n      {regex: /.*/, token: \"string\"}\n    ],\n    string2: [\n      {regex: /^;/, token: \"keyword\", next: \"start\"},\n      {regex: /.*/, token: \"string\"}\n    ],\n    string3: [\n      {regex: /(?:[^\\\\]|\\\\.)*?\"\"\"/, token: \"string\", next: \"start\"},\n      {regex: /.*/, token: \"string\"}\n    ],\n    stack: [\n      {regex: /\\)/, token: \"bracket\", next: \"start\"},\n      {regex: /--/, token: \"bracket\"},\n      {regex: /\\S+/, token: \"meta\"},\n      {regex: /\\s+|./, token: null}\n    ],\n    // The meta property contains global information about the mode. It\n    // can contain properties like lineComment, which are supported by\n    // all modes, and also directives like dontIndentStates, which are\n    // specific to simple modes.\n    meta: {\n      dontIndentStates: [\"start\", \"vocabulary\", \"string\", \"string3\", \"stack\"],\n      lineComment: [ \"!\", \"#!\" ]\n    }\n  });\n\n  CodeMirror.defineMIME(\"text/x-factor\", \"factor\");\n});\n"]},"metadata":{},"sourceType":"script"}