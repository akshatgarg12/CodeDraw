{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"crystal\", function (config) {\n    function wordRegExp(words, end) {\n      return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n    }\n\n    function chain(tokenize, stream, state) {\n      state.tokenize.push(tokenize);\n      return tokenize(stream, state);\n    }\n\n    var operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\n    var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\n    var indexingOperators = /^(?:\\[\\][?=]?)/;\n    var anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\n    var idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var keywords = wordRegExp([\"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\", \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\", \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\", \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\", \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\", \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"]);\n    var atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\n    var indentKeywordsArray = [\"def\", \"fun\", \"macro\", \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\", \"do\", \"for\"];\n    var indentKeywords = wordRegExp(indentKeywordsArray);\n    var indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\n    var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\n    var dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\n    var dedentKeywords = wordRegExp(dedentKeywordsArray);\n    var dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\n    var dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\n    var nextTokenizer = {\n      \"def\": tokenFollowIdent,\n      \"fun\": tokenFollowIdent,\n      \"macro\": tokenMacroDef,\n      \"class\": tokenFollowType,\n      \"module\": tokenFollowType,\n      \"struct\": tokenFollowType,\n      \"lib\": tokenFollowType,\n      \"enum\": tokenFollowType,\n      \"union\": tokenFollowType\n    };\n    var matching = {\n      \"[\": \"]\",\n      \"{\": \"}\",\n      \"(\": \")\",\n      \"<\": \">\"\n    };\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      } // Macros\n\n\n      if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n        return chain(tokenMacro(\"%\", \"%\"), stream, state);\n      }\n\n      if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n        return chain(tokenMacro(\"{\", \"}\"), stream, state);\n      } // Comments\n\n\n      if (stream.peek() == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      } // Variables and keywords\n\n\n      var matched;\n\n      if (stream.match(idents)) {\n        stream.eat(/[?!]/);\n        matched = stream.current();\n\n        if (stream.eat(\":\")) {\n          return \"atom\";\n        } else if (state.lastToken == \".\") {\n          return \"property\";\n        } else if (keywords.test(matched)) {\n          if (indentKeywords.test(matched)) {\n            if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n              state.blocks.push(matched);\n              state.currentIndent += 1;\n            }\n          } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n            state.blocks.push(matched);\n            state.currentIndent += 1;\n          } else if (matched == \"end\") {\n            state.blocks.pop();\n            state.currentIndent -= 1;\n          }\n\n          if (nextTokenizer.hasOwnProperty(matched)) {\n            state.tokenize.push(nextTokenizer[matched]);\n          }\n\n          return \"keyword\";\n        } else if (atomWords.test(matched)) {\n          return \"atom\";\n        }\n\n        return \"variable\";\n      } // Class variables and instance variables\n      // or attributes\n\n\n      if (stream.eat(\"@\")) {\n        if (stream.peek() == \"[\") {\n          return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n        }\n\n        stream.eat(\"@\");\n        stream.match(idents) || stream.match(types);\n        return \"variable-2\";\n      } // Constants and types\n\n\n      if (stream.match(types)) {\n        return \"tag\";\n      } // Symbols or ':' operator\n\n\n      if (stream.eat(\":\")) {\n        if (stream.eat(\"\\\"\")) {\n          return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n        } else if (stream.match(idents) || stream.match(types) || stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n          return \"atom\";\n        }\n\n        stream.eat(\":\");\n        return \"operator\";\n      } // Strings\n\n\n      if (stream.eat(\"\\\"\")) {\n        return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n      } // Strings or regexps or macro variables or '%' operator\n\n\n      if (stream.peek() == \"%\") {\n        var style = \"string\";\n        var embed = true;\n        var delim;\n\n        if (stream.match(\"%r\")) {\n          // Regexps\n          style = \"string-2\";\n          delim = stream.next();\n        } else if (stream.match(\"%w\")) {\n          embed = false;\n          delim = stream.next();\n        } else if (stream.match(\"%q\")) {\n          embed = false;\n          delim = stream.next();\n        } else {\n          if (delim = stream.match(/^%([^\\w\\s=])/)) {\n            delim = delim[1];\n          } else if (stream.match(/^%[a-zA-Z0-9_\\u009F-\\uFFFF]*/)) {\n            // Macro variables\n            return \"meta\";\n          } else {\n            // '%' operator\n            return \"operator\";\n          }\n        }\n\n        if (matching.hasOwnProperty(delim)) {\n          delim = matching[delim];\n        }\n\n        return chain(tokenQuote(delim, style, embed), stream, state);\n      } // Here Docs\n\n\n      if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n        return chain(tokenHereDoc(matched[2], !matched[1]), stream, state);\n      } // Characters\n\n\n      if (stream.eat(\"'\")) {\n        stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n        stream.eat(\"'\");\n        return \"atom\";\n      } // Numbers\n\n\n      if (stream.eat(\"0\")) {\n        if (stream.eat(\"x\")) {\n          stream.match(/^[0-9a-fA-F]+/);\n        } else if (stream.eat(\"o\")) {\n          stream.match(/^[0-7]+/);\n        } else if (stream.eat(\"b\")) {\n          stream.match(/^[01]+/);\n        }\n\n        return \"number\";\n      }\n\n      if (stream.eat(/^\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/);\n        return \"number\";\n      } // Operators\n\n\n      if (stream.match(operators)) {\n        stream.eat(\"=\"); // Operators can follow assign symbol.\n\n        return \"operator\";\n      }\n\n      if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n        return \"operator\";\n      } // Parens and braces\n\n\n      if (matched = stream.match(/[({[]/, false)) {\n        matched = matched[0];\n        return chain(tokenNest(matched, matching[matched], null), stream, state);\n      } // Escapes\n\n\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        return \"meta\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenNest(begin, end, style, started) {\n      return function (stream, state) {\n        if (!started && stream.match(begin)) {\n          state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n          state.currentIndent += 1;\n          return style;\n        }\n\n        var nextStyle = tokenBase(stream, state);\n\n        if (stream.current() === end) {\n          state.tokenize.pop();\n          state.currentIndent -= 1;\n          nextStyle = style;\n        }\n\n        return nextStyle;\n      };\n    }\n\n    function tokenMacro(begin, end, started) {\n      return function (stream, state) {\n        if (!started && stream.match(\"{\" + begin)) {\n          state.currentIndent += 1;\n          state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n          return \"meta\";\n        }\n\n        if (stream.match(end + \"}\")) {\n          state.currentIndent -= 1;\n          state.tokenize.pop();\n          return \"meta\";\n        }\n\n        return tokenBase(stream, state);\n      };\n    }\n\n    function tokenMacroDef(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var matched;\n\n      if (matched = stream.match(idents)) {\n        if (matched == \"def\") {\n          return \"keyword\";\n        }\n\n        stream.eat(/[?!]/);\n      }\n\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowIdent(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (stream.match(idents)) {\n        stream.eat(/[!?]/);\n      } else {\n        stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n      }\n\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowType(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(types);\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenQuote(end, style, embed) {\n      return function (stream, state) {\n        var escaped = false;\n\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return style;\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return style;\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return style;\n            }\n\n            var ch = stream.next();\n\n            if (ch == end) {\n              state.tokenize.pop();\n              return style;\n            }\n\n            escaped = embed && ch == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return style;\n      };\n    }\n\n    function tokenHereDoc(phrase, embed) {\n      return function (stream, state) {\n        if (stream.sol()) {\n          stream.eatSpace();\n\n          if (stream.match(phrase)) {\n            state.tokenize.pop();\n            return \"string\";\n          }\n        }\n\n        var escaped = false;\n\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return \"string\";\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return \"string\";\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return \"string\";\n            }\n\n            escaped = embed && stream.next() == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return \"string\";\n      };\n    }\n\n    return {\n      startState: function () {\n        return {\n          tokenize: [tokenBase],\n          currentIndent: 0,\n          lastToken: null,\n          lastStyle: null,\n          blocks: []\n        };\n      },\n      token: function (stream, state) {\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        var token = stream.current();\n\n        if (style && style != \"comment\") {\n          state.lastToken = token;\n          state.lastStyle = style;\n        }\n\n        return style;\n      },\n      indent: function (state, textAfter) {\n        textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n        if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n          return config.indentUnit * (state.currentIndent - 1);\n        }\n\n        return config.indentUnit * state.currentIndent;\n      },\n      fold: \"indent\",\n      electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n      lineComment: '#'\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-crystal\", \"crystal\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/crystal/crystal.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","wordRegExp","words","end","RegExp","join","chain","tokenize","stream","state","push","operators","conditionalOperators","indexingOperators","anotherOperators","idents","types","keywords","atomWords","indentKeywordsArray","indentKeywords","indentExpressionKeywordsArray","indentExpressionKeywords","dedentKeywordsArray","dedentKeywords","dedentPunctualsArray","dedentPunctuals","nextTokenizer","tokenFollowIdent","tokenMacroDef","tokenFollowType","matching","tokenBase","eatSpace","lastToken","match","tokenMacro","peek","skipToEnd","matched","eat","current","test","blocks","indexOf","currentIndent","lastStyle","pop","hasOwnProperty","tokenNest","tokenQuote","style","embed","delim","next","tokenHereDoc","begin","started","length","nextStyle","escaped","ch","phrase","sol","startState","token","indent","textAfter","replace","indentUnit","fold","electricInput","concat","lineComment","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"crystal\", function(config) {\n    function wordRegExp(words, end) {\n      return new RegExp((end ? \"\" : \"^\") + \"(?:\" + words.join(\"|\") + \")\" + (end ? \"$\" : \"\\\\b\"));\n    }\n\n    function chain(tokenize, stream, state) {\n      state.tokenize.push(tokenize);\n      return tokenize(stream, state);\n    }\n\n    var operators = /^(?:[-+/%|&^]|\\*\\*?|[<>]{2})/;\n    var conditionalOperators = /^(?:[=!]~|===|<=>|[<>=!]=?|[|&]{2}|~)/;\n    var indexingOperators = /^(?:\\[\\][?=]?)/;\n    var anotherOperators = /^(?:\\.(?:\\.{2})?|->|[?:])/;\n    var idents = /^[a-z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var types = /^[A-Z_\\u009F-\\uFFFF][a-zA-Z0-9_\\u009F-\\uFFFF]*/;\n    var keywords = wordRegExp([\n      \"abstract\", \"alias\", \"as\", \"asm\", \"begin\", \"break\", \"case\", \"class\", \"def\", \"do\",\n      \"else\", \"elsif\", \"end\", \"ensure\", \"enum\", \"extend\", \"for\", \"fun\", \"if\",\n      \"include\", \"instance_sizeof\", \"lib\", \"macro\", \"module\", \"next\", \"of\", \"out\", \"pointerof\",\n      \"private\", \"protected\", \"rescue\", \"return\", \"require\", \"select\", \"sizeof\", \"struct\",\n      \"super\", \"then\", \"type\", \"typeof\", \"uninitialized\", \"union\", \"unless\", \"until\", \"when\", \"while\", \"with\",\n      \"yield\", \"__DIR__\", \"__END_LINE__\", \"__FILE__\", \"__LINE__\"\n    ]);\n    var atomWords = wordRegExp([\"true\", \"false\", \"nil\", \"self\"]);\n    var indentKeywordsArray = [\n      \"def\", \"fun\", \"macro\",\n      \"class\", \"module\", \"struct\", \"lib\", \"enum\", \"union\",\n      \"do\", \"for\"\n    ];\n    var indentKeywords = wordRegExp(indentKeywordsArray);\n    var indentExpressionKeywordsArray = [\"if\", \"unless\", \"case\", \"while\", \"until\", \"begin\", \"then\"];\n    var indentExpressionKeywords = wordRegExp(indentExpressionKeywordsArray);\n    var dedentKeywordsArray = [\"end\", \"else\", \"elsif\", \"rescue\", \"ensure\"];\n    var dedentKeywords = wordRegExp(dedentKeywordsArray);\n    var dedentPunctualsArray = [\"\\\\)\", \"\\\\}\", \"\\\\]\"];\n    var dedentPunctuals = new RegExp(\"^(?:\" + dedentPunctualsArray.join(\"|\") + \")$\");\n    var nextTokenizer = {\n      \"def\": tokenFollowIdent, \"fun\": tokenFollowIdent, \"macro\": tokenMacroDef,\n      \"class\": tokenFollowType, \"module\": tokenFollowType, \"struct\": tokenFollowType,\n      \"lib\": tokenFollowType, \"enum\": tokenFollowType, \"union\": tokenFollowType\n    };\n    var matching = {\"[\": \"]\", \"{\": \"}\", \"(\": \")\", \"<\": \">\"};\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      // Macros\n      if (state.lastToken != \"\\\\\" && stream.match(\"{%\", false)) {\n        return chain(tokenMacro(\"%\", \"%\"), stream, state);\n      }\n\n      if (state.lastToken != \"\\\\\" && stream.match(\"{{\", false)) {\n        return chain(tokenMacro(\"{\", \"}\"), stream, state);\n      }\n\n      // Comments\n      if (stream.peek() == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      // Variables and keywords\n      var matched;\n      if (stream.match(idents)) {\n        stream.eat(/[?!]/);\n\n        matched = stream.current();\n        if (stream.eat(\":\")) {\n          return \"atom\";\n        } else if (state.lastToken == \".\") {\n          return \"property\";\n        } else if (keywords.test(matched)) {\n          if (indentKeywords.test(matched)) {\n            if (!(matched == \"fun\" && state.blocks.indexOf(\"lib\") >= 0) && !(matched == \"def\" && state.lastToken == \"abstract\")) {\n              state.blocks.push(matched);\n              state.currentIndent += 1;\n            }\n          } else if ((state.lastStyle == \"operator\" || !state.lastStyle) && indentExpressionKeywords.test(matched)) {\n            state.blocks.push(matched);\n            state.currentIndent += 1;\n          } else if (matched == \"end\") {\n            state.blocks.pop();\n            state.currentIndent -= 1;\n          }\n\n          if (nextTokenizer.hasOwnProperty(matched)) {\n            state.tokenize.push(nextTokenizer[matched]);\n          }\n\n          return \"keyword\";\n        } else if (atomWords.test(matched)) {\n          return \"atom\";\n        }\n\n        return \"variable\";\n      }\n\n      // Class variables and instance variables\n      // or attributes\n      if (stream.eat(\"@\")) {\n        if (stream.peek() == \"[\") {\n          return chain(tokenNest(\"[\", \"]\", \"meta\"), stream, state);\n        }\n\n        stream.eat(\"@\");\n        stream.match(idents) || stream.match(types);\n        return \"variable-2\";\n      }\n\n      // Constants and types\n      if (stream.match(types)) {\n        return \"tag\";\n      }\n\n      // Symbols or ':' operator\n      if (stream.eat(\":\")) {\n        if (stream.eat(\"\\\"\")) {\n          return chain(tokenQuote(\"\\\"\", \"atom\", false), stream, state);\n        } else if (stream.match(idents) || stream.match(types) ||\n                   stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators)) {\n          return \"atom\";\n        }\n        stream.eat(\":\");\n        return \"operator\";\n      }\n\n      // Strings\n      if (stream.eat(\"\\\"\")) {\n        return chain(tokenQuote(\"\\\"\", \"string\", true), stream, state);\n      }\n\n      // Strings or regexps or macro variables or '%' operator\n      if (stream.peek() == \"%\") {\n        var style = \"string\";\n        var embed = true;\n        var delim;\n\n        if (stream.match(\"%r\")) {\n          // Regexps\n          style = \"string-2\";\n          delim = stream.next();\n        } else if (stream.match(\"%w\")) {\n          embed = false;\n          delim = stream.next();\n        } else if (stream.match(\"%q\")) {\n          embed = false;\n          delim = stream.next();\n        } else {\n          if(delim = stream.match(/^%([^\\w\\s=])/)) {\n            delim = delim[1];\n          } else if (stream.match(/^%[a-zA-Z0-9_\\u009F-\\uFFFF]*/)) {\n            // Macro variables\n            return \"meta\";\n          } else {\n            // '%' operator\n            return \"operator\";\n          }\n        }\n\n        if (matching.hasOwnProperty(delim)) {\n          delim = matching[delim];\n        }\n        return chain(tokenQuote(delim, style, embed), stream, state);\n      }\n\n      // Here Docs\n      if (matched = stream.match(/^<<-('?)([A-Z]\\w*)\\1/)) {\n        return chain(tokenHereDoc(matched[2], !matched[1]), stream, state)\n      }\n\n      // Characters\n      if (stream.eat(\"'\")) {\n        stream.match(/^(?:[^']|\\\\(?:[befnrtv0'\"]|[0-7]{3}|u(?:[0-9a-fA-F]{4}|\\{[0-9a-fA-F]{1,6}\\})))/);\n        stream.eat(\"'\");\n        return \"atom\";\n      }\n\n      // Numbers\n      if (stream.eat(\"0\")) {\n        if (stream.eat(\"x\")) {\n          stream.match(/^[0-9a-fA-F]+/);\n        } else if (stream.eat(\"o\")) {\n          stream.match(/^[0-7]+/);\n        } else if (stream.eat(\"b\")) {\n          stream.match(/^[01]+/);\n        }\n        return \"number\";\n      }\n\n      if (stream.eat(/^\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d+)?(?:[eE][+-]?\\d+)?/);\n        return \"number\";\n      }\n\n      // Operators\n      if (stream.match(operators)) {\n        stream.eat(\"=\"); // Operators can follow assign symbol.\n        return \"operator\";\n      }\n\n      if (stream.match(conditionalOperators) || stream.match(anotherOperators)) {\n        return \"operator\";\n      }\n\n      // Parens and braces\n      if (matched = stream.match(/[({[]/, false)) {\n        matched = matched[0];\n        return chain(tokenNest(matched, matching[matched], null), stream, state);\n      }\n\n      // Escapes\n      if (stream.eat(\"\\\\\")) {\n        stream.next();\n        return \"meta\";\n      }\n\n      stream.next();\n      return null;\n    }\n\n    function tokenNest(begin, end, style, started) {\n      return function (stream, state) {\n        if (!started && stream.match(begin)) {\n          state.tokenize[state.tokenize.length - 1] = tokenNest(begin, end, style, true);\n          state.currentIndent += 1;\n          return style;\n        }\n\n        var nextStyle = tokenBase(stream, state);\n        if (stream.current() === end) {\n          state.tokenize.pop();\n          state.currentIndent -= 1;\n          nextStyle = style;\n        }\n\n        return nextStyle;\n      };\n    }\n\n    function tokenMacro(begin, end, started) {\n      return function (stream, state) {\n        if (!started && stream.match(\"{\" + begin)) {\n          state.currentIndent += 1;\n          state.tokenize[state.tokenize.length - 1] = tokenMacro(begin, end, true);\n          return \"meta\";\n        }\n\n        if (stream.match(end + \"}\")) {\n          state.currentIndent -= 1;\n          state.tokenize.pop();\n          return \"meta\";\n        }\n\n        return tokenBase(stream, state);\n      };\n    }\n\n    function tokenMacroDef(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      var matched;\n      if (matched = stream.match(idents)) {\n        if (matched == \"def\") {\n          return \"keyword\";\n        }\n        stream.eat(/[?!]/);\n      }\n\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowIdent(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (stream.match(idents)) {\n        stream.eat(/[!?]/);\n      } else {\n        stream.match(operators) || stream.match(conditionalOperators) || stream.match(indexingOperators);\n      }\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenFollowType(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(types);\n      state.tokenize.pop();\n      return \"def\";\n    }\n\n    function tokenQuote(end, style, embed) {\n      return function (stream, state) {\n        var escaped = false;\n\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return style;\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return style;\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return style;\n            }\n\n            var ch = stream.next();\n\n            if (ch == end) {\n              state.tokenize.pop();\n              return style;\n            }\n\n            escaped = embed && ch == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return style;\n      };\n    }\n\n    function tokenHereDoc(phrase, embed) {\n      return function (stream, state) {\n        if (stream.sol()) {\n          stream.eatSpace()\n          if (stream.match(phrase)) {\n            state.tokenize.pop();\n            return \"string\";\n          }\n        }\n\n        var escaped = false;\n        while (stream.peek()) {\n          if (!escaped) {\n            if (stream.match(\"{%\", false)) {\n              state.tokenize.push(tokenMacro(\"%\", \"%\"));\n              return \"string\";\n            }\n\n            if (stream.match(\"{{\", false)) {\n              state.tokenize.push(tokenMacro(\"{\", \"}\"));\n              return \"string\";\n            }\n\n            if (embed && stream.match(\"#{\", false)) {\n              state.tokenize.push(tokenNest(\"#{\", \"}\", \"meta\"));\n              return \"string\";\n            }\n\n            escaped = embed && stream.next() == \"\\\\\";\n          } else {\n            stream.next();\n            escaped = false;\n          }\n        }\n\n        return \"string\";\n      }\n    }\n\n    return {\n      startState: function () {\n        return {\n          tokenize: [tokenBase],\n          currentIndent: 0,\n          lastToken: null,\n          lastStyle: null,\n          blocks: []\n        };\n      },\n\n      token: function (stream, state) {\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        var token = stream.current();\n\n        if (style && style != \"comment\") {\n          state.lastToken = token;\n          state.lastStyle = style;\n        }\n\n        return style;\n      },\n\n      indent: function (state, textAfter) {\n        textAfter = textAfter.replace(/^\\s*(?:\\{%)?\\s*|\\s*(?:%\\})?\\s*$/g, \"\");\n\n        if (dedentKeywords.test(textAfter) || dedentPunctuals.test(textAfter)) {\n          return config.indentUnit * (state.currentIndent - 1);\n        }\n\n        return config.indentUnit * state.currentIndent;\n      },\n\n      fold: \"indent\",\n      electricInput: wordRegExp(dedentPunctualsArray.concat(dedentKeywordsArray), true),\n      lineComment: '#'\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-crystal\", \"crystal\");\n});\n"]},"metadata":{},"sourceType":"script"}