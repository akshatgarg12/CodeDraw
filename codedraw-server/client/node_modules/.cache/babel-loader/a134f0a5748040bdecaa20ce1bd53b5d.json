{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../clike/clike\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../clike/clike\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  var keywords = (\"this super static final const abstract class extends external factory \" + \"implements mixin get native set typedef with enum throw rethrow \" + \"assert break case continue default in return new deferred async await covariant \" + \"try catch finally do else for if switch while import library export \" + \"part of show hide is as extension on yield late required\").split(\" \");\n  var blockKeywords = \"try catch finally do else for if switch while\".split(\" \");\n  var atoms = \"true false null\".split(\" \");\n  var builtins = \"void bool num int double dynamic var String Null Never\".split(\" \");\n\n  function set(words) {\n    var obj = {};\n\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n    return obj;\n  }\n\n  function pushInterpolationStack(state) {\n    (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);\n  }\n\n  function popInterpolationStack(state) {\n    return (state.interpolationStack || (state.interpolationStack = [])).pop();\n  }\n\n  function sizeInterpolationStack(state) {\n    return state.interpolationStack ? state.interpolationStack.length : 0;\n  }\n\n  CodeMirror.defineMIME(\"application/dart\", {\n    name: \"clike\",\n    keywords: set(keywords),\n    blockKeywords: set(blockKeywords),\n    builtin: set(builtins),\n    atoms: set(atoms),\n    hooks: {\n      \"@\": function (stream) {\n        stream.eatWhile(/[\\w\\$_\\.]/);\n        return \"meta\";\n      },\n      // custom string handling to deal with triple-quoted strings and string interpolation\n      \"'\": function (stream, state) {\n        return tokenString(\"'\", stream, state, false);\n      },\n      \"\\\"\": function (stream, state) {\n        return tokenString(\"\\\"\", stream, state, false);\n      },\n      \"r\": function (stream, state) {\n        var peek = stream.peek();\n\n        if (peek == \"'\" || peek == \"\\\"\") {\n          return tokenString(stream.next(), stream, state, true);\n        }\n\n        return false;\n      },\n      \"}\": function (_stream, state) {\n        // \"}\" is end of interpolation, if interpolation stack is non-empty\n        if (sizeInterpolationStack(state) > 0) {\n          state.tokenize = popInterpolationStack(state);\n          return null;\n        }\n\n        return false;\n      },\n      \"/\": function (stream, state) {\n        if (!stream.eat(\"*\")) return false;\n        state.tokenize = tokenNestedComment(1);\n        return state.tokenize(stream, state);\n      },\n      token: function (stream, _, style) {\n        if (style == \"variable\") {\n          // Assume uppercase symbols are classes using variable-2\n          var isUpper = RegExp('^[_$]*[A-Z][a-zA-Z0-9_$]*$', 'g');\n\n          if (isUpper.test(stream.current())) {\n            return 'variable-2';\n          }\n        }\n      }\n    }\n  });\n\n  function tokenString(quote, stream, state, raw) {\n    var tripleQuoted = false;\n\n    if (stream.eat(quote)) {\n      if (stream.eat(quote)) tripleQuoted = true;else return \"string\"; //empty string\n    }\n\n    function tokenStringHelper(stream, state) {\n      var escaped = false;\n\n      while (!stream.eol()) {\n        if (!raw && !escaped && stream.peek() == \"$\") {\n          pushInterpolationStack(state);\n          state.tokenize = tokenInterpolation;\n          return \"string\";\n        }\n\n        var next = stream.next();\n\n        if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {\n          state.tokenize = null;\n          break;\n        }\n\n        escaped = !raw && !escaped && next == \"\\\\\";\n      }\n\n      return \"string\";\n    }\n\n    state.tokenize = tokenStringHelper;\n    return tokenStringHelper(stream, state);\n  }\n\n  function tokenInterpolation(stream, state) {\n    stream.eat(\"$\");\n\n    if (stream.eat(\"{\")) {\n      // let clike handle the content of ${...},\n      // we take over again when \"}\" appears (see hooks).\n      state.tokenize = null;\n    } else {\n      state.tokenize = tokenInterpolationIdentifier;\n    }\n\n    return null;\n  }\n\n  function tokenInterpolationIdentifier(stream, state) {\n    stream.eatWhile(/[\\w_]/);\n    state.tokenize = popInterpolationStack(state);\n    return \"variable\";\n  }\n\n  function tokenNestedComment(depth) {\n    return function (stream, state) {\n      var ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"*\" && stream.eat(\"/\")) {\n          if (depth == 1) {\n            state.tokenize = null;\n            break;\n          } else {\n            state.tokenize = tokenNestedComment(depth - 1);\n            return state.tokenize(stream, state);\n          }\n        } else if (ch == \"/\" && stream.eat(\"*\")) {\n          state.tokenize = tokenNestedComment(depth + 1);\n          return state.tokenize(stream, state);\n        }\n      }\n\n      return \"comment\";\n    };\n  }\n\n  CodeMirror.registerHelper(\"hintWords\", \"application/dart\", keywords.concat(atoms).concat(builtins)); // This is needed to make loading through meta.js work.\n\n  CodeMirror.defineMode(\"dart\", function (conf) {\n    return CodeMirror.getMode(conf, \"application/dart\");\n  }, \"clike\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/dart/dart.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","keywords","split","blockKeywords","atoms","builtins","set","words","obj","i","length","pushInterpolationStack","state","interpolationStack","push","tokenize","popInterpolationStack","pop","sizeInterpolationStack","defineMIME","name","builtin","hooks","stream","eatWhile","tokenString","peek","next","_stream","eat","tokenNestedComment","token","_","style","isUpper","RegExp","test","current","quote","raw","tripleQuoted","tokenStringHelper","escaped","eol","tokenInterpolation","match","tokenInterpolationIdentifier","depth","ch","registerHelper","concat","defineMode","conf","getMode"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../clike/clike\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../clike/clike\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  var keywords = (\"this super static final const abstract class extends external factory \" +\n    \"implements mixin get native set typedef with enum throw rethrow \" +\n    \"assert break case continue default in return new deferred async await covariant \" +\n    \"try catch finally do else for if switch while import library export \" +\n    \"part of show hide is as extension on yield late required\").split(\" \");\n  var blockKeywords = \"try catch finally do else for if switch while\".split(\" \");\n  var atoms = \"true false null\".split(\" \");\n  var builtins = \"void bool num int double dynamic var String Null Never\".split(\" \");\n\n  function set(words) {\n    var obj = {};\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n\n  function pushInterpolationStack(state) {\n    (state.interpolationStack || (state.interpolationStack = [])).push(state.tokenize);\n  }\n\n  function popInterpolationStack(state) {\n    return (state.interpolationStack || (state.interpolationStack = [])).pop();\n  }\n\n  function sizeInterpolationStack(state) {\n    return state.interpolationStack ? state.interpolationStack.length : 0;\n  }\n\n  CodeMirror.defineMIME(\"application/dart\", {\n    name: \"clike\",\n    keywords: set(keywords),\n    blockKeywords: set(blockKeywords),\n    builtin: set(builtins),\n    atoms: set(atoms),\n    hooks: {\n      \"@\": function(stream) {\n        stream.eatWhile(/[\\w\\$_\\.]/);\n        return \"meta\";\n      },\n\n      // custom string handling to deal with triple-quoted strings and string interpolation\n      \"'\": function(stream, state) {\n        return tokenString(\"'\", stream, state, false);\n      },\n      \"\\\"\": function(stream, state) {\n        return tokenString(\"\\\"\", stream, state, false);\n      },\n      \"r\": function(stream, state) {\n        var peek = stream.peek();\n        if (peek == \"'\" || peek == \"\\\"\") {\n          return tokenString(stream.next(), stream, state, true);\n        }\n        return false;\n      },\n\n      \"}\": function(_stream, state) {\n        // \"}\" is end of interpolation, if interpolation stack is non-empty\n        if (sizeInterpolationStack(state) > 0) {\n          state.tokenize = popInterpolationStack(state);\n          return null;\n        }\n        return false;\n      },\n\n      \"/\": function(stream, state) {\n        if (!stream.eat(\"*\")) return false\n        state.tokenize = tokenNestedComment(1)\n        return state.tokenize(stream, state)\n      },\n      token: function(stream, _, style) {\n        if (style == \"variable\") {\n          // Assume uppercase symbols are classes using variable-2\n          var isUpper = RegExp('^[_$]*[A-Z][a-zA-Z0-9_$]*$','g');\n          if (isUpper.test(stream.current())) {\n            return 'variable-2';\n          }\n        }\n      }\n    }\n  });\n\n  function tokenString(quote, stream, state, raw) {\n    var tripleQuoted = false;\n    if (stream.eat(quote)) {\n      if (stream.eat(quote)) tripleQuoted = true;\n      else return \"string\"; //empty string\n    }\n    function tokenStringHelper(stream, state) {\n      var escaped = false;\n      while (!stream.eol()) {\n        if (!raw && !escaped && stream.peek() == \"$\") {\n          pushInterpolationStack(state);\n          state.tokenize = tokenInterpolation;\n          return \"string\";\n        }\n        var next = stream.next();\n        if (next == quote && !escaped && (!tripleQuoted || stream.match(quote + quote))) {\n          state.tokenize = null;\n          break;\n        }\n        escaped = !raw && !escaped && next == \"\\\\\";\n      }\n      return \"string\";\n    }\n    state.tokenize = tokenStringHelper;\n    return tokenStringHelper(stream, state);\n  }\n\n  function tokenInterpolation(stream, state) {\n    stream.eat(\"$\");\n    if (stream.eat(\"{\")) {\n      // let clike handle the content of ${...},\n      // we take over again when \"}\" appears (see hooks).\n      state.tokenize = null;\n    } else {\n      state.tokenize = tokenInterpolationIdentifier;\n    }\n    return null;\n  }\n\n  function tokenInterpolationIdentifier(stream, state) {\n    stream.eatWhile(/[\\w_]/);\n    state.tokenize = popInterpolationStack(state);\n    return \"variable\";\n  }\n\n  function tokenNestedComment(depth) {\n    return function (stream, state) {\n      var ch\n      while (ch = stream.next()) {\n        if (ch == \"*\" && stream.eat(\"/\")) {\n          if (depth == 1) {\n            state.tokenize = null\n            break\n          } else {\n            state.tokenize = tokenNestedComment(depth - 1)\n            return state.tokenize(stream, state)\n          }\n        } else if (ch == \"/\" && stream.eat(\"*\")) {\n          state.tokenize = tokenNestedComment(depth + 1)\n          return state.tokenize(stream, state)\n        }\n      }\n      return \"comment\"\n    }\n  }\n\n  CodeMirror.registerHelper(\"hintWords\", \"application/dart\", keywords.concat(atoms).concat(builtins));\n\n  // This is needed to make loading through meta.js work.\n  CodeMirror.defineMode(\"dart\", function(conf) {\n    return CodeMirror.getMode(conf, \"application/dart\");\n  }, \"clike\");\n});\n"]},"metadata":{},"sourceType":"script"}