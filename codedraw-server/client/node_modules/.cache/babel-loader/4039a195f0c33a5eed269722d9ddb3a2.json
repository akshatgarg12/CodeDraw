{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Smarty 2 and 3 mode.\n */\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"smarty\", function (config, parserConf) {\n    var rightDelimiter = parserConf.rightDelimiter || \"}\";\n    var leftDelimiter = parserConf.leftDelimiter || \"{\";\n    var version = parserConf.version || 2;\n    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || \"null\");\n    var keyFunctions = [\"debug\", \"extends\", \"function\", \"include\", \"literal\"];\n    var regs = {\n      operatorChars: /[+\\-*&%=<>!?]/,\n      validIdentifier: /[a-zA-Z0-9_]/,\n      stringChar: /['\"]/\n    };\n    var last;\n\n    function cont(style, lastType) {\n      last = lastType;\n      return style;\n    }\n\n    function chain(stream, state, parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    } // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode\n\n\n    function doesNotCount(stream, pos) {\n      if (pos == null) pos = stream.pos;\n      return version === 3 && leftDelimiter == \"{\" && (pos == stream.string.length || /\\s/.test(stream.string.charAt(pos)));\n    }\n\n    function tokenTop(stream, state) {\n      var string = stream.string;\n\n      for (var scan = stream.pos;;) {\n        var nextMatch = string.indexOf(leftDelimiter, scan);\n        scan = nextMatch + leftDelimiter.length;\n        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;\n      }\n\n      if (nextMatch == stream.pos) {\n        stream.match(leftDelimiter);\n\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, tokenBlock(\"comment\", \"*\" + rightDelimiter));\n        } else {\n          state.depth++;\n          state.tokenize = tokenSmarty;\n          last = \"startTag\";\n          return \"tag\";\n        }\n      }\n\n      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);\n      var token = baseMode.token(stream, state.base);\n      if (nextMatch > -1) stream.string = string;\n      return token;\n    } // parsing Smarty content\n\n\n    function tokenSmarty(stream, state) {\n      if (stream.match(rightDelimiter, true)) {\n        if (version === 3) {\n          state.depth--;\n\n          if (state.depth <= 0) {\n            state.tokenize = tokenTop;\n          }\n        } else {\n          state.tokenize = tokenTop;\n        }\n\n        return cont(\"tag\", null);\n      }\n\n      if (stream.match(leftDelimiter, true)) {\n        state.depth++;\n        return cont(\"tag\", \"startTag\");\n      }\n\n      var ch = stream.next();\n\n      if (ch == \"$\") {\n        stream.eatWhile(regs.validIdentifier);\n        return cont(\"variable-2\", \"variable\");\n      } else if (ch == \"|\") {\n        return cont(\"operator\", \"pipe\");\n      } else if (ch == \".\") {\n        return cont(\"operator\", \"property\");\n      } else if (regs.stringChar.test(ch)) {\n        state.tokenize = tokenAttribute(ch);\n        return cont(\"string\", \"string\");\n      } else if (regs.operatorChars.test(ch)) {\n        stream.eatWhile(regs.operatorChars);\n        return cont(\"operator\", \"operator\");\n      } else if (ch == \"[\" || ch == \"]\") {\n        return cont(\"bracket\", \"bracket\");\n      } else if (ch == \"(\" || ch == \")\") {\n        return cont(\"bracket\", \"operator\");\n      } else if (/\\d/.test(ch)) {\n        stream.eatWhile(/\\d/);\n        return cont(\"number\", \"number\");\n      } else {\n        if (state.last == \"variable\") {\n          if (ch == \"@\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"property\", \"property\");\n          } else if (ch == \"|\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"qualifier\", \"modifier\");\n          }\n        } else if (state.last == \"pipe\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"qualifier\", \"modifier\");\n        } else if (state.last == \"whitespace\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"attribute\", \"modifier\");\n        }\n\n        if (state.last == \"property\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"property\", null);\n        } else if (/\\s/.test(ch)) {\n          last = \"whitespace\";\n          return null;\n        }\n\n        var str = \"\";\n\n        if (ch != \"/\") {\n          str += ch;\n        }\n\n        var c = null;\n\n        while (c = stream.eat(regs.validIdentifier)) {\n          str += c;\n        }\n\n        for (var i = 0, j = keyFunctions.length; i < j; i++) {\n          if (keyFunctions[i] == str) {\n            return cont(\"keyword\", \"keyword\");\n          }\n        }\n\n        if (/\\s/.test(ch)) {\n          return null;\n        }\n\n        return cont(\"tag\", \"tag\");\n      }\n    }\n\n    function tokenAttribute(quote) {\n      return function (stream, state) {\n        var prevChar = null;\n        var currChar = null;\n\n        while (!stream.eol()) {\n          currChar = stream.peek();\n\n          if (stream.next() == quote && prevChar !== '\\\\') {\n            state.tokenize = tokenSmarty;\n            break;\n          }\n\n          prevChar = currChar;\n        }\n\n        return \"string\";\n      };\n    }\n\n    function tokenBlock(style, terminator) {\n      return function (stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenTop;\n            break;\n          }\n\n          stream.next();\n        }\n\n        return style;\n      };\n    }\n\n    return {\n      startState: function startState() {\n        return {\n          base: CodeMirror.startState(baseMode),\n          tokenize: tokenTop,\n          last: null,\n          depth: 0\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          base: CodeMirror.copyState(baseMode, state.base),\n          tokenize: state.tokenize,\n          last: state.last,\n          depth: state.depth\n        };\n      },\n      innerMode: function innerMode(state) {\n        if (state.tokenize == tokenTop) return {\n          mode: baseMode,\n          state: state.base\n        };\n      },\n      token: function token(stream, state) {\n        var style = state.tokenize(stream, state);\n        state.last = last;\n        return style;\n      },\n      indent: function indent(state, text, line) {\n        if (state.tokenize == tokenTop && baseMode.indent) return baseMode.indent(state.base, text, line);else return CodeMirror.Pass;\n      },\n      blockCommentStart: leftDelimiter + \"*\",\n      blockCommentEnd: \"*\" + rightDelimiter\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-smarty\", \"smarty\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/smarty/smarty.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConf","rightDelimiter","leftDelimiter","version","baseMode","getMode","keyFunctions","regs","operatorChars","validIdentifier","stringChar","last","cont","style","lastType","chain","stream","state","parser","tokenize","doesNotCount","pos","string","length","test","charAt","tokenTop","scan","nextMatch","indexOf","match","eat","tokenBlock","depth","tokenSmarty","slice","token","base","ch","next","eatWhile","tokenAttribute","str","c","i","j","quote","prevChar","currChar","eol","peek","terminator","startState","copyState","innerMode","mode","indent","text","line","Pass","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n/**\n * Smarty 2 and 3 mode.\n */\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"smarty\", function(config, parserConf) {\n    var rightDelimiter = parserConf.rightDelimiter || \"}\";\n    var leftDelimiter = parserConf.leftDelimiter || \"{\";\n    var version = parserConf.version || 2;\n    var baseMode = CodeMirror.getMode(config, parserConf.baseMode || \"null\");\n\n    var keyFunctions = [\"debug\", \"extends\", \"function\", \"include\", \"literal\"];\n    var regs = {\n      operatorChars: /[+\\-*&%=<>!?]/,\n      validIdentifier: /[a-zA-Z0-9_]/,\n      stringChar: /['\"]/\n    };\n\n    var last;\n    function cont(style, lastType) {\n      last = lastType;\n      return style;\n    }\n\n    function chain(stream, state, parser) {\n      state.tokenize = parser;\n      return parser(stream, state);\n    }\n\n    // Smarty 3 allows { and } surrounded by whitespace to NOT slip into Smarty mode\n    function doesNotCount(stream, pos) {\n      if (pos == null) pos = stream.pos;\n      return version === 3 && leftDelimiter == \"{\" &&\n        (pos == stream.string.length || /\\s/.test(stream.string.charAt(pos)));\n    }\n\n    function tokenTop(stream, state) {\n      var string = stream.string;\n      for (var scan = stream.pos;;) {\n        var nextMatch = string.indexOf(leftDelimiter, scan);\n        scan = nextMatch + leftDelimiter.length;\n        if (nextMatch == -1 || !doesNotCount(stream, nextMatch + leftDelimiter.length)) break;\n      }\n      if (nextMatch == stream.pos) {\n        stream.match(leftDelimiter);\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, tokenBlock(\"comment\", \"*\" + rightDelimiter));\n        } else {\n          state.depth++;\n          state.tokenize = tokenSmarty;\n          last = \"startTag\";\n          return \"tag\";\n        }\n      }\n\n      if (nextMatch > -1) stream.string = string.slice(0, nextMatch);\n      var token = baseMode.token(stream, state.base);\n      if (nextMatch > -1) stream.string = string;\n      return token;\n    }\n\n    // parsing Smarty content\n    function tokenSmarty(stream, state) {\n      if (stream.match(rightDelimiter, true)) {\n        if (version === 3) {\n          state.depth--;\n          if (state.depth <= 0) {\n            state.tokenize = tokenTop;\n          }\n        } else {\n          state.tokenize = tokenTop;\n        }\n        return cont(\"tag\", null);\n      }\n\n      if (stream.match(leftDelimiter, true)) {\n        state.depth++;\n        return cont(\"tag\", \"startTag\");\n      }\n\n      var ch = stream.next();\n      if (ch == \"$\") {\n        stream.eatWhile(regs.validIdentifier);\n        return cont(\"variable-2\", \"variable\");\n      } else if (ch == \"|\") {\n        return cont(\"operator\", \"pipe\");\n      } else if (ch == \".\") {\n        return cont(\"operator\", \"property\");\n      } else if (regs.stringChar.test(ch)) {\n        state.tokenize = tokenAttribute(ch);\n        return cont(\"string\", \"string\");\n      } else if (regs.operatorChars.test(ch)) {\n        stream.eatWhile(regs.operatorChars);\n        return cont(\"operator\", \"operator\");\n      } else if (ch == \"[\" || ch == \"]\") {\n        return cont(\"bracket\", \"bracket\");\n      } else if (ch == \"(\" || ch == \")\") {\n        return cont(\"bracket\", \"operator\");\n      } else if (/\\d/.test(ch)) {\n        stream.eatWhile(/\\d/);\n        return cont(\"number\", \"number\");\n      } else {\n\n        if (state.last == \"variable\") {\n          if (ch == \"@\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"property\", \"property\");\n          } else if (ch == \"|\") {\n            stream.eatWhile(regs.validIdentifier);\n            return cont(\"qualifier\", \"modifier\");\n          }\n        } else if (state.last == \"pipe\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"qualifier\", \"modifier\");\n        } else if (state.last == \"whitespace\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"attribute\", \"modifier\");\n        } if (state.last == \"property\") {\n          stream.eatWhile(regs.validIdentifier);\n          return cont(\"property\", null);\n        } else if (/\\s/.test(ch)) {\n          last = \"whitespace\";\n          return null;\n        }\n\n        var str = \"\";\n        if (ch != \"/\") {\n          str += ch;\n        }\n        var c = null;\n        while (c = stream.eat(regs.validIdentifier)) {\n          str += c;\n        }\n        for (var i=0, j=keyFunctions.length; i<j; i++) {\n          if (keyFunctions[i] == str) {\n            return cont(\"keyword\", \"keyword\");\n          }\n        }\n        if (/\\s/.test(ch)) {\n          return null;\n        }\n        return cont(\"tag\", \"tag\");\n      }\n    }\n\n    function tokenAttribute(quote) {\n      return function(stream, state) {\n        var prevChar = null;\n        var currChar = null;\n        while (!stream.eol()) {\n          currChar = stream.peek();\n          if (stream.next() == quote && prevChar !== '\\\\') {\n            state.tokenize = tokenSmarty;\n            break;\n          }\n          prevChar = currChar;\n        }\n        return \"string\";\n      };\n    }\n\n    function tokenBlock(style, terminator) {\n      return function(stream, state) {\n        while (!stream.eol()) {\n          if (stream.match(terminator)) {\n            state.tokenize = tokenTop;\n            break;\n          }\n          stream.next();\n        }\n        return style;\n      };\n    }\n\n    return {\n      startState: function() {\n        return {\n          base: CodeMirror.startState(baseMode),\n          tokenize: tokenTop,\n          last: null,\n          depth: 0\n        };\n      },\n      copyState: function(state) {\n        return {\n          base: CodeMirror.copyState(baseMode, state.base),\n          tokenize: state.tokenize,\n          last: state.last,\n          depth: state.depth\n        };\n      },\n      innerMode: function(state) {\n        if (state.tokenize == tokenTop)\n          return {mode: baseMode, state: state.base};\n      },\n      token: function(stream, state) {\n        var style = state.tokenize(stream, state);\n        state.last = last;\n        return style;\n      },\n      indent: function(state, text, line) {\n        if (state.tokenize == tokenTop && baseMode.indent)\n          return baseMode.indent(state.base, text, line);\n        else\n          return CodeMirror.Pass;\n      },\n      blockCommentStart: leftDelimiter + \"*\",\n      blockCommentEnd: \"*\" + rightDelimiter\n    };\n  });\n\n  CodeMirror.defineMIME(\"text/x-smarty\", \"smarty\");\n});\n"]},"metadata":{},"sourceType":"script"}