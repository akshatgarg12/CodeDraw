{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"groovy\", function (config) {\n    function words(str) {\n      var obj = {},\n          words = str.split(\" \");\n\n      for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n\n      return obj;\n    }\n\n    var keywords = words(\"abstract as assert boolean break byte case catch char class const continue def default \" + \"do double else enum extends final finally float for goto if implements import in \" + \"instanceof int interface long native new package private protected public return \" + \"short static strictfp super switch synchronized threadsafe throw throws trait transient \" + \"try void volatile while\");\n    var blockKeywords = words(\"catch class def do else enum finally for if interface switch trait try while\");\n    var standaloneKeywords = words(\"return break continue\");\n    var atoms = words(\"null true false this\");\n    var curPunc;\n\n    function tokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == '\"' || ch == \"'\") {\n        return startString(ch, stream, state);\n      }\n\n      if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        curPunc = ch;\n        return null;\n      }\n\n      if (/\\d/.test(ch)) {\n        stream.eatWhile(/[\\w\\.]/);\n\n        if (stream.eat(/eE/)) {\n          stream.eat(/\\+\\-/);\n          stream.eatWhile(/\\d/);\n        }\n\n        return \"number\";\n      }\n\n      if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize.push(tokenComment);\n          return tokenComment(stream, state);\n        }\n\n        if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        if (expectExpression(state.lastToken, false)) {\n          return startString(ch, stream, state);\n        }\n      }\n\n      if (ch == \"-\" && stream.eat(\">\")) {\n        curPunc = \"->\";\n        return null;\n      }\n\n      if (/[+\\-*&%=<>!?|\\/~]/.test(ch)) {\n        stream.eatWhile(/[+\\-*&%=<>|~]/);\n        return \"operator\";\n      }\n\n      stream.eatWhile(/[\\w\\$_]/);\n\n      if (ch == \"@\") {\n        stream.eatWhile(/[\\w\\$_\\.]/);\n        return \"meta\";\n      }\n\n      if (state.lastToken == \".\") return \"property\";\n\n      if (stream.eat(\":\")) {\n        curPunc = \"proplabel\";\n        return \"property\";\n      }\n\n      var cur = stream.current();\n\n      if (atoms.propertyIsEnumerable(cur)) {\n        return \"atom\";\n      }\n\n      if (keywords.propertyIsEnumerable(cur)) {\n        if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";else if (standaloneKeywords.propertyIsEnumerable(cur)) curPunc = \"standalone\";\n        return \"keyword\";\n      }\n\n      return \"variable\";\n    }\n\n    tokenBase.isBase = true;\n\n    function startString(quote, stream, state) {\n      var tripleQuoted = false;\n\n      if (quote != \"/\" && stream.eat(quote)) {\n        if (stream.eat(quote)) tripleQuoted = true;else return \"string\";\n      }\n\n      function t(stream, state) {\n        var escaped = false,\n            next,\n            end = !tripleQuoted;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            if (!tripleQuoted) {\n              break;\n            }\n\n            if (stream.match(quote + quote)) {\n              end = true;\n              break;\n            }\n          }\n\n          if (quote == '\"' && next == \"$\" && !escaped && stream.eat(\"{\")) {\n            state.tokenize.push(tokenBaseUntilBrace());\n            return \"string\";\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end) state.tokenize.pop();\n        return \"string\";\n      }\n\n      state.tokenize.push(t);\n      return t(stream, state);\n    }\n\n    function tokenBaseUntilBrace() {\n      var depth = 1;\n\n      function t(stream, state) {\n        if (stream.peek() == \"}\") {\n          depth--;\n\n          if (depth == 0) {\n            state.tokenize.pop();\n            return state.tokenize[state.tokenize.length - 1](stream, state);\n          }\n        } else if (stream.peek() == \"{\") {\n          depth++;\n        }\n\n        return tokenBase(stream, state);\n      }\n\n      t.isBase = true;\n      return t;\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize.pop();\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function expectExpression(last, newline) {\n      return !last || last == \"operator\" || last == \"->\" || /[\\.\\[\\{\\(,;:]/.test(last) || last == \"newstatement\" || last == \"keyword\" || last == \"proplabel\" || last == \"standalone\" && !newline;\n    }\n\n    function Context(indented, column, type, align, prev) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.align = align;\n      this.prev = prev;\n    }\n\n    function pushContext(state, col, type) {\n      return state.context = new Context(state.indented, col, type, null, state.context);\n    }\n\n    function popContext(state) {\n      var t = state.context.type;\n      if (t == \")\" || t == \"]\" || t == \"}\") state.indented = state.context.indented;\n      return state.context = state.context.prev;\n    } // Interface\n\n\n    return {\n      startState: function (basecolumn) {\n        return {\n          tokenize: [tokenBase],\n          context: new Context((basecolumn || 0) - config.indentUnit, 0, \"top\", false),\n          indented: 0,\n          startOfLine: true,\n          lastToken: null\n        };\n      },\n      token: function (stream, state) {\n        var ctx = state.context;\n\n        if (stream.sol()) {\n          if (ctx.align == null) ctx.align = false;\n          state.indented = stream.indentation();\n          state.startOfLine = true; // Automatic semicolon insertion\n\n          if (ctx.type == \"statement\" && !expectExpression(state.lastToken, true)) {\n            popContext(state);\n            ctx = state.context;\n          }\n        }\n\n        if (stream.eatSpace()) return null;\n        curPunc = null;\n        var style = state.tokenize[state.tokenize.length - 1](stream, state);\n        if (style == \"comment\") return style;\n        if (ctx.align == null) ctx.align = true;\n        if ((curPunc == \";\" || curPunc == \":\") && ctx.type == \"statement\") popContext(state); // Handle indentation for {x -> \\n ... }\n        else if (curPunc == \"->\" && ctx.type == \"statement\" && ctx.prev.type == \"}\") {\n            popContext(state);\n            state.context.align = false;\n          } else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");else if (curPunc == \"}\") {\n            while (ctx.type == \"statement\") ctx = popContext(state);\n\n            if (ctx.type == \"}\") ctx = popContext(state);\n\n            while (ctx.type == \"statement\") ctx = popContext(state);\n          } else if (curPunc == ctx.type) popContext(state);else if (ctx.type == \"}\" || ctx.type == \"top\" || ctx.type == \"statement\" && curPunc == \"newstatement\") pushContext(state, stream.column(), \"statement\");\n        state.startOfLine = false;\n        state.lastToken = curPunc || style;\n        return style;\n      },\n      indent: function (state, textAfter) {\n        if (!state.tokenize[state.tokenize.length - 1].isBase) return CodeMirror.Pass;\n        var firstChar = textAfter && textAfter.charAt(0),\n            ctx = state.context;\n        if (ctx.type == \"statement\" && !expectExpression(state.lastToken, true)) ctx = ctx.prev;\n        var closing = firstChar == ctx.type;\n        if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : config.indentUnit);else if (ctx.align) return ctx.column + (closing ? 0 : 1);else return ctx.indented + (closing ? 0 : config.indentUnit);\n      },\n      electricChars: \"{}\",\n      closeBrackets: {\n        triples: \"'\\\"\"\n      },\n      fold: \"brace\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-groovy\", \"groovy\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/groovy/groovy.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","words","str","obj","split","i","length","keywords","blockKeywords","standaloneKeywords","atoms","curPunc","tokenBase","stream","state","ch","next","startString","test","eatWhile","eat","tokenize","push","tokenComment","skipToEnd","expectExpression","lastToken","cur","current","propertyIsEnumerable","isBase","quote","tripleQuoted","t","escaped","end","match","tokenBaseUntilBrace","pop","depth","peek","maybeEnd","last","newline","Context","indented","column","type","align","prev","pushContext","col","context","popContext","startState","basecolumn","indentUnit","startOfLine","token","ctx","sol","indentation","eatSpace","style","indent","textAfter","Pass","firstChar","charAt","closing","electricChars","closeBrackets","triples","fold","blockCommentStart","blockCommentEnd","lineComment","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"groovy\", function(config) {\n  function words(str) {\n    var obj = {}, words = str.split(\" \");\n    for (var i = 0; i < words.length; ++i) obj[words[i]] = true;\n    return obj;\n  }\n  var keywords = words(\n    \"abstract as assert boolean break byte case catch char class const continue def default \" +\n    \"do double else enum extends final finally float for goto if implements import in \" +\n    \"instanceof int interface long native new package private protected public return \" +\n    \"short static strictfp super switch synchronized threadsafe throw throws trait transient \" +\n    \"try void volatile while\");\n  var blockKeywords = words(\"catch class def do else enum finally for if interface switch trait try while\");\n  var standaloneKeywords = words(\"return break continue\");\n  var atoms = words(\"null true false this\");\n\n  var curPunc;\n  function tokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      return startString(ch, stream, state);\n    }\n    if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      curPunc = ch;\n      return null;\n    }\n    if (/\\d/.test(ch)) {\n      stream.eatWhile(/[\\w\\.]/);\n      if (stream.eat(/eE/)) { stream.eat(/\\+\\-/); stream.eatWhile(/\\d/); }\n      return \"number\";\n    }\n    if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize.push(tokenComment);\n        return tokenComment(stream, state);\n      }\n      if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      if (expectExpression(state.lastToken, false)) {\n        return startString(ch, stream, state);\n      }\n    }\n    if (ch == \"-\" && stream.eat(\">\")) {\n      curPunc = \"->\";\n      return null;\n    }\n    if (/[+\\-*&%=<>!?|\\/~]/.test(ch)) {\n      stream.eatWhile(/[+\\-*&%=<>|~]/);\n      return \"operator\";\n    }\n    stream.eatWhile(/[\\w\\$_]/);\n    if (ch == \"@\") { stream.eatWhile(/[\\w\\$_\\.]/); return \"meta\"; }\n    if (state.lastToken == \".\") return \"property\";\n    if (stream.eat(\":\")) { curPunc = \"proplabel\"; return \"property\"; }\n    var cur = stream.current();\n    if (atoms.propertyIsEnumerable(cur)) { return \"atom\"; }\n    if (keywords.propertyIsEnumerable(cur)) {\n      if (blockKeywords.propertyIsEnumerable(cur)) curPunc = \"newstatement\";\n      else if (standaloneKeywords.propertyIsEnumerable(cur)) curPunc = \"standalone\";\n      return \"keyword\";\n    }\n    return \"variable\";\n  }\n  tokenBase.isBase = true;\n\n  function startString(quote, stream, state) {\n    var tripleQuoted = false;\n    if (quote != \"/\" && stream.eat(quote)) {\n      if (stream.eat(quote)) tripleQuoted = true;\n      else return \"string\";\n    }\n    function t(stream, state) {\n      var escaped = false, next, end = !tripleQuoted;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          if (!tripleQuoted) { break; }\n          if (stream.match(quote + quote)) { end = true; break; }\n        }\n        if (quote == '\"' && next == \"$\" && !escaped && stream.eat(\"{\")) {\n          state.tokenize.push(tokenBaseUntilBrace());\n          return \"string\";\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end) state.tokenize.pop();\n      return \"string\";\n    }\n    state.tokenize.push(t);\n    return t(stream, state);\n  }\n\n  function tokenBaseUntilBrace() {\n    var depth = 1;\n    function t(stream, state) {\n      if (stream.peek() == \"}\") {\n        depth--;\n        if (depth == 0) {\n          state.tokenize.pop();\n          return state.tokenize[state.tokenize.length-1](stream, state);\n        }\n      } else if (stream.peek() == \"{\") {\n        depth++;\n      }\n      return tokenBase(stream, state);\n    }\n    t.isBase = true;\n    return t;\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize.pop();\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function expectExpression(last, newline) {\n    return !last || last == \"operator\" || last == \"->\" || /[\\.\\[\\{\\(,;:]/.test(last) ||\n      last == \"newstatement\" || last == \"keyword\" || last == \"proplabel\" ||\n      (last == \"standalone\" && !newline);\n  }\n\n  function Context(indented, column, type, align, prev) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.align = align;\n    this.prev = prev;\n  }\n  function pushContext(state, col, type) {\n    return state.context = new Context(state.indented, col, type, null, state.context);\n  }\n  function popContext(state) {\n    var t = state.context.type;\n    if (t == \")\" || t == \"]\" || t == \"}\")\n      state.indented = state.context.indented;\n    return state.context = state.context.prev;\n  }\n\n  // Interface\n\n  return {\n    startState: function(basecolumn) {\n      return {\n        tokenize: [tokenBase],\n        context: new Context((basecolumn || 0) - config.indentUnit, 0, \"top\", false),\n        indented: 0,\n        startOfLine: true,\n        lastToken: null\n      };\n    },\n\n    token: function(stream, state) {\n      var ctx = state.context;\n      if (stream.sol()) {\n        if (ctx.align == null) ctx.align = false;\n        state.indented = stream.indentation();\n        state.startOfLine = true;\n        // Automatic semicolon insertion\n        if (ctx.type == \"statement\" && !expectExpression(state.lastToken, true)) {\n          popContext(state); ctx = state.context;\n        }\n      }\n      if (stream.eatSpace()) return null;\n      curPunc = null;\n      var style = state.tokenize[state.tokenize.length-1](stream, state);\n      if (style == \"comment\") return style;\n      if (ctx.align == null) ctx.align = true;\n\n      if ((curPunc == \";\" || curPunc == \":\") && ctx.type == \"statement\") popContext(state);\n      // Handle indentation for {x -> \\n ... }\n      else if (curPunc == \"->\" && ctx.type == \"statement\" && ctx.prev.type == \"}\") {\n        popContext(state);\n        state.context.align = false;\n      }\n      else if (curPunc == \"{\") pushContext(state, stream.column(), \"}\");\n      else if (curPunc == \"[\") pushContext(state, stream.column(), \"]\");\n      else if (curPunc == \"(\") pushContext(state, stream.column(), \")\");\n      else if (curPunc == \"}\") {\n        while (ctx.type == \"statement\") ctx = popContext(state);\n        if (ctx.type == \"}\") ctx = popContext(state);\n        while (ctx.type == \"statement\") ctx = popContext(state);\n      }\n      else if (curPunc == ctx.type) popContext(state);\n      else if (ctx.type == \"}\" || ctx.type == \"top\" || (ctx.type == \"statement\" && curPunc == \"newstatement\"))\n        pushContext(state, stream.column(), \"statement\");\n      state.startOfLine = false;\n      state.lastToken = curPunc || style;\n      return style;\n    },\n\n    indent: function(state, textAfter) {\n      if (!state.tokenize[state.tokenize.length-1].isBase) return CodeMirror.Pass;\n      var firstChar = textAfter && textAfter.charAt(0), ctx = state.context;\n      if (ctx.type == \"statement\" && !expectExpression(state.lastToken, true)) ctx = ctx.prev;\n      var closing = firstChar == ctx.type;\n      if (ctx.type == \"statement\") return ctx.indented + (firstChar == \"{\" ? 0 : config.indentUnit);\n      else if (ctx.align) return ctx.column + (closing ? 0 : 1);\n      else return ctx.indented + (closing ? 0 : config.indentUnit);\n    },\n\n    electricChars: \"{}\",\n    closeBrackets: {triples: \"'\\\"\"},\n    fold: \"brace\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-groovy\", \"groovy\");\n\n});\n"]},"metadata":{},"sourceType":"script"}