{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"haxe\", function (config, parserConfig) {\n    var indentUnit = config.indentUnit; // Tokenizer\n\n    function kw(type) {\n      return {\n        type: type,\n        style: \"keyword\"\n      };\n    }\n\n    var A = kw(\"keyword a\"),\n        B = kw(\"keyword b\"),\n        C = kw(\"keyword c\");\n    var operator = kw(\"operator\"),\n        atom = {\n      type: \"atom\",\n      style: \"atom\"\n    },\n        attribute = {\n      type: \"attribute\",\n      style: \"attribute\"\n    };\n    var type = kw(\"typedef\");\n    var keywords = {\n      \"if\": A,\n      \"while\": A,\n      \"else\": B,\n      \"do\": B,\n      \"try\": B,\n      \"return\": C,\n      \"break\": C,\n      \"continue\": C,\n      \"new\": C,\n      \"throw\": C,\n      \"var\": kw(\"var\"),\n      \"inline\": attribute,\n      \"static\": attribute,\n      \"using\": kw(\"import\"),\n      \"public\": attribute,\n      \"private\": attribute,\n      \"cast\": kw(\"cast\"),\n      \"import\": kw(\"import\"),\n      \"macro\": kw(\"macro\"),\n      \"function\": kw(\"function\"),\n      \"catch\": kw(\"catch\"),\n      \"untyped\": kw(\"untyped\"),\n      \"callback\": kw(\"cb\"),\n      \"for\": kw(\"for\"),\n      \"switch\": kw(\"switch\"),\n      \"case\": kw(\"case\"),\n      \"default\": kw(\"default\"),\n      \"in\": operator,\n      \"never\": kw(\"property_access\"),\n      \"trace\": kw(\"trace\"),\n      \"class\": type,\n      \"abstract\": type,\n      \"enum\": type,\n      \"interface\": type,\n      \"typedef\": type,\n      \"extends\": type,\n      \"implements\": type,\n      \"dynamic\": type,\n      \"true\": atom,\n      \"false\": atom,\n      \"null\": atom\n    };\n    var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n    function chain(stream, state, f) {\n      state.tokenize = f;\n      return f(stream, state);\n    }\n\n    function toUnescaped(stream, end) {\n      var escaped = false,\n          next;\n\n      while ((next = stream.next()) != null) {\n        if (next == end && !escaped) return true;\n        escaped = !escaped && next == \"\\\\\";\n      }\n    } // Used as scratch variables to communicate multiple values without\n    // consing up tons of objects.\n\n\n    var type, content;\n\n    function ret(tp, style, cont) {\n      type = tp;\n      content = cont;\n      return style;\n    }\n\n    function haxeTokenBase(stream, state) {\n      var ch = stream.next();\n\n      if (ch == '\"' || ch == \"'\") {\n        return chain(stream, state, haxeTokenString(ch));\n      } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n        return ret(ch);\n      } else if (ch == \"0\" && stream.eat(/x/i)) {\n        stream.eatWhile(/[\\da-f]/i);\n        return ret(\"number\", \"number\");\n      } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n        stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n        return ret(\"number\", \"number\");\n      } else if (state.reAllowed && ch == \"~\" && stream.eat(/\\//)) {\n        toUnescaped(stream, \"/\");\n        stream.eatWhile(/[gimsu]/);\n        return ret(\"regexp\", \"string-2\");\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          return chain(stream, state, haxeTokenComment);\n        } else if (stream.eat(\"/\")) {\n          stream.skipToEnd();\n          return ret(\"comment\", \"comment\");\n        } else {\n          stream.eatWhile(isOperatorChar);\n          return ret(\"operator\", null, stream.current());\n        }\n      } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n      } else if (ch == \"@\") {\n        stream.eat(/:/);\n        stream.eatWhile(/[\\w_]/);\n        return ret(\"metadata\", \"meta\");\n      } else if (isOperatorChar.test(ch)) {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      } else {\n        var word;\n\n        if (/[A-Z]/.test(ch)) {\n          stream.eatWhile(/[\\w_<>]/);\n          word = stream.current();\n          return ret(\"type\", \"variable-3\", word);\n        } else {\n          stream.eatWhile(/[\\w_]/);\n          var word = stream.current(),\n              known = keywords.propertyIsEnumerable(word) && keywords[word];\n          return known && state.kwAllowed ? ret(known.type, known.style, word) : ret(\"variable\", \"variable\", word);\n        }\n      }\n    }\n\n    function haxeTokenString(quote) {\n      return function (stream, state) {\n        if (toUnescaped(stream, quote)) state.tokenize = haxeTokenBase;\n        return ret(\"string\", \"string\");\n      };\n    }\n\n    function haxeTokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = haxeTokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return ret(\"comment\", \"comment\");\n    } // Parser\n\n\n    var atomicTypes = {\n      \"atom\": true,\n      \"number\": true,\n      \"variable\": true,\n      \"string\": true,\n      \"regexp\": true\n    };\n\n    function HaxeLexical(indented, column, type, align, prev, info) {\n      this.indented = indented;\n      this.column = column;\n      this.type = type;\n      this.prev = prev;\n      this.info = info;\n      if (align != null) this.align = align;\n    }\n\n    function inScope(state, varname) {\n      for (var v = state.localVars; v; v = v.next) {\n        if (v.name == varname) return true;\n      }\n    }\n\n    function parseHaxe(state, style, type, content, stream) {\n      var cc = state.cc; // Communicate our context to the combinators.\n      // (Less wasteful than consing up a hundred closures on every call.)\n\n      cx.state = state;\n      cx.stream = stream;\n      cx.marked = null, cx.cc = cc;\n      if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = true;\n\n      while (true) {\n        var combinator = cc.length ? cc.pop() : statement;\n\n        if (combinator(type, content)) {\n          while (cc.length && cc[cc.length - 1].lex) {\n            cc.pop()();\n          }\n\n          if (cx.marked) return cx.marked;\n          if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n          if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n          return style;\n        }\n      }\n    }\n\n    function imported(state, typename) {\n      if (/[a-z]/.test(typename.charAt(0))) return false;\n      var len = state.importedtypes.length;\n\n      for (var i = 0; i < len; i++) {\n        if (state.importedtypes[i] == typename) return true;\n      }\n    }\n\n    function registerimport(importname) {\n      var state = cx.state;\n\n      for (var t = state.importedtypes; t; t = t.next) {\n        if (t.name == importname) return;\n      }\n\n      state.importedtypes = {\n        name: importname,\n        next: state.importedtypes\n      };\n    } // Combinator utils\n\n\n    var cx = {\n      state: null,\n      column: null,\n      marked: null,\n      cc: null\n    };\n\n    function pass() {\n      for (var i = arguments.length - 1; i >= 0; i--) {\n        cx.cc.push(arguments[i]);\n      }\n    }\n\n    function cont() {\n      pass.apply(null, arguments);\n      return true;\n    }\n\n    function inList(name, list) {\n      for (var v = list; v; v = v.next) {\n        if (v.name == name) return true;\n      }\n\n      return false;\n    }\n\n    function register(varname) {\n      var state = cx.state;\n\n      if (state.context) {\n        cx.marked = \"def\";\n        if (inList(varname, state.localVars)) return;\n        state.localVars = {\n          name: varname,\n          next: state.localVars\n        };\n      } else if (state.globalVars) {\n        if (inList(varname, state.globalVars)) return;\n        state.globalVars = {\n          name: varname,\n          next: state.globalVars\n        };\n      }\n    } // Combinators\n\n\n    var defaultVars = {\n      name: \"this\",\n      next: null\n    };\n\n    function pushcontext() {\n      if (!cx.state.context) cx.state.localVars = defaultVars;\n      cx.state.context = {\n        prev: cx.state.context,\n        vars: cx.state.localVars\n      };\n    }\n\n    function popcontext() {\n      cx.state.localVars = cx.state.context.vars;\n      cx.state.context = cx.state.context.prev;\n    }\n\n    popcontext.lex = true;\n\n    function pushlex(type, info) {\n      var result = function result() {\n        var state = cx.state;\n        state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n      };\n\n      result.lex = true;\n      return result;\n    }\n\n    function poplex() {\n      var state = cx.state;\n\n      if (state.lexical.prev) {\n        if (state.lexical.type == \")\") state.indented = state.lexical.indented;\n        state.lexical = state.lexical.prev;\n      }\n    }\n\n    poplex.lex = true;\n\n    function expect(wanted) {\n      function f(type) {\n        if (type == wanted) return cont();else if (wanted == \";\") return pass();else return cont(f);\n      }\n\n      return f;\n    }\n\n    function statement(type) {\n      if (type == \"@\") return cont(metadef);\n      if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n      if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n      if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n      if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n      if (type == \";\") return cont();\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"), poplex, statement, poplex);\n      if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n      if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"), block, poplex, poplex);\n      if (type == \"case\") return cont(expression, expect(\":\"));\n      if (type == \"default\") return cont(expect(\":\"));\n      if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"), statement, poplex, popcontext);\n      if (type == \"import\") return cont(importdef, expect(\";\"));\n      if (type == \"typedef\") return cont(typedef);\n      return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n    }\n\n    function expression(type) {\n      if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n      if (type == \"type\") return cont(maybeoperator);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"keyword c\") return cont(maybeexpression);\n      if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n      if (type == \"operator\") return cont(expression);\n      if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n      return cont();\n    }\n\n    function maybeexpression(type) {\n      if (type.match(/[;\\}\\)\\],]/)) return pass();\n      return pass(expression);\n    }\n\n    function maybeoperator(type, value) {\n      if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n      if (type == \"operator\" || type == \":\") return cont(expression);\n      if (type == \";\") return;\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n      if (type == \".\") return cont(property, maybeoperator);\n      if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n    }\n\n    function maybeattribute(type) {\n      if (type == \"attribute\") return cont(maybeattribute);\n      if (type == \"function\") return cont(functiondef);\n      if (type == \"var\") return cont(vardef1);\n    }\n\n    function metadef(type) {\n      if (type == \":\") return cont(metadef);\n      if (type == \"variable\") return cont(metadef);\n      if (type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n    }\n\n    function metaargs(type) {\n      if (type == \"variable\") return cont();\n    }\n\n    function importdef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n    }\n\n    function typedef(type, value) {\n      if (type == \"variable\" && /[A-Z]/.test(value.charAt(0))) {\n        registerimport(value);\n        return cont();\n      } else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) {\n        return cont();\n      }\n    }\n\n    function maybelabel(type) {\n      if (type == \":\") return cont(poplex, statement);\n      return pass(maybeoperator, expect(\";\"), poplex);\n    }\n\n    function property(type) {\n      if (type == \"variable\") {\n        cx.marked = \"property\";\n        return cont();\n      }\n    }\n\n    function objprop(type) {\n      if (type == \"variable\") cx.marked = \"property\";\n      if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n    }\n\n    function commasep(what, end) {\n      function proceed(type) {\n        if (type == \",\") return cont(what, proceed);\n        if (type == end) return cont();\n        return cont(expect(end));\n      }\n\n      return function (type) {\n        if (type == end) return cont();else return pass(what, proceed);\n      };\n    }\n\n    function block(type) {\n      if (type == \"}\") return cont();\n      return pass(statement, block);\n    }\n\n    function vardef1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse, vardef2);\n      }\n\n      return cont();\n    }\n\n    function vardef2(type, value) {\n      if (value == \"=\") return cont(expression, vardef2);\n      if (type == \",\") return cont(vardef1);\n    }\n\n    function forspec1(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(forin, expression);\n      } else {\n        return pass();\n      }\n    }\n\n    function forin(_type, value) {\n      if (value == \"in\") return cont();\n    }\n\n    function functiondef(type, value) {\n      //function names starting with upper-case letters are recognised as types, so cludging them together here.\n      if (type == \"variable\" || type == \"type\") {\n        register(value);\n        return cont(functiondef);\n      }\n\n      if (value == \"new\") return cont(functiondef);\n      if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n    }\n\n    function typeuse(type) {\n      if (type == \":\") return cont(typestring);\n    }\n\n    function typestring(type) {\n      if (type == \"type\") return cont();\n      if (type == \"variable\") return cont();\n      if (type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n    }\n\n    function typeprop(type) {\n      if (type == \"variable\") return cont(typeuse);\n    }\n\n    function funarg(type, value) {\n      if (type == \"variable\") {\n        register(value);\n        return cont(typeuse);\n      }\n    } // Interface\n\n\n    return {\n      startState: function startState(basecolumn) {\n        var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n        var state = {\n          tokenize: haxeTokenBase,\n          reAllowed: true,\n          kwAllowed: true,\n          cc: [],\n          lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n          localVars: parserConfig.localVars,\n          importedtypes: defaulttypes,\n          context: parserConfig.localVars && {\n            vars: parserConfig.localVars\n          },\n          indented: 0\n        };\n        if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\") state.globalVars = parserConfig.globalVars;\n        return state;\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          if (!state.lexical.hasOwnProperty(\"align\")) state.lexical.align = false;\n          state.indented = stream.indentation();\n        }\n\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        if (type == \"comment\") return style;\n        state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n        state.kwAllowed = type != '.';\n        return parseHaxe(state, style, type, content, stream);\n      },\n      indent: function indent(state, textAfter) {\n        if (state.tokenize != haxeTokenBase) return 0;\n        var firstChar = textAfter && textAfter.charAt(0),\n            lexical = state.lexical;\n        if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n        var type = lexical.type,\n            closing = firstChar == type;\n        if (type == \"vardef\") return lexical.indented + 4;else if (type == \"form\" && firstChar == \"{\") return lexical.indented;else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;else if (lexical.info == \"switch\" && !closing) return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);else if (lexical.align) return lexical.column + (closing ? 0 : 1);else return lexical.indented + (closing ? 0 : indentUnit);\n      },\n      electricChars: \"{}\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\",\n      lineComment: \"//\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n  CodeMirror.defineMode(\"hxml\", function () {\n    return {\n      startState: function startState() {\n        return {\n          define: false,\n          inString: false\n        };\n      },\n      token: function token(stream, state) {\n        var ch = stream.peek();\n        var sol = stream.sol(); ///* comments */\n\n        if (ch == \"#\") {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n\n        if (sol && ch == \"-\") {\n          var style = \"variable-2\";\n          stream.eat(/-/);\n\n          if (stream.peek() == \"-\") {\n            stream.eat(/-/);\n            style = \"keyword a\";\n          }\n\n          if (stream.peek() == \"D\") {\n            stream.eat(/[D]/);\n            style = \"keyword c\";\n            state.define = true;\n          }\n\n          stream.eatWhile(/[A-Z]/i);\n          return style;\n        }\n\n        var ch = stream.peek();\n\n        if (state.inString == false && ch == \"'\") {\n          state.inString = true;\n          stream.next();\n        }\n\n        if (state.inString == true) {\n          if (stream.skipTo(\"'\")) {} else {\n            stream.skipToEnd();\n          }\n\n          if (stream.peek() == \"'\") {\n            stream.next();\n            state.inString = false;\n          }\n\n          return \"string\";\n        }\n\n        stream.next();\n        return null;\n      },\n      lineComment: \"#\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/haxe/haxe.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","parserConfig","indentUnit","kw","type","style","A","B","C","operator","atom","attribute","keywords","isOperatorChar","chain","stream","state","f","tokenize","toUnescaped","end","escaped","next","content","ret","tp","cont","haxeTokenBase","ch","haxeTokenString","test","eat","eatWhile","match","reAllowed","haxeTokenComment","skipToEnd","current","word","known","propertyIsEnumerable","kwAllowed","quote","maybeEnd","atomicTypes","HaxeLexical","indented","column","align","prev","info","inScope","varname","v","localVars","name","parseHaxe","cc","cx","marked","lexical","hasOwnProperty","combinator","length","pop","statement","lex","imported","typename","charAt","len","importedtypes","i","registerimport","importname","t","pass","arguments","push","apply","inList","list","register","context","globalVars","defaultVars","pushcontext","vars","popcontext","pushlex","result","poplex","expect","wanted","metadef","vardef1","expression","block","maybeattribute","functiondef","forspec1","maybelabel","funarg","importdef","typedef","maybeoperator","maybeexpression","commasep","objprop","value","property","metaargs","what","proceed","typeuse","vardef2","forin","_type","typestring","typeprop","startState","basecolumn","defaulttypes","token","sol","indentation","eatSpace","indent","textAfter","firstChar","closing","electricChars","blockCommentStart","blockCommentEnd","lineComment","defineMIME","inString","peek","skipTo"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"haxe\", function(config, parserConfig) {\n  var indentUnit = config.indentUnit;\n\n  // Tokenizer\n\n  function kw(type) {return {type: type, style: \"keyword\"};}\n  var A = kw(\"keyword a\"), B = kw(\"keyword b\"), C = kw(\"keyword c\");\n  var operator = kw(\"operator\"), atom = {type: \"atom\", style: \"atom\"}, attribute = {type:\"attribute\", style: \"attribute\"};\n  var type = kw(\"typedef\");\n  var keywords = {\n    \"if\": A, \"while\": A, \"else\": B, \"do\": B, \"try\": B,\n    \"return\": C, \"break\": C, \"continue\": C, \"new\": C, \"throw\": C,\n    \"var\": kw(\"var\"), \"inline\":attribute, \"static\": attribute, \"using\":kw(\"import\"),\n    \"public\": attribute, \"private\": attribute, \"cast\": kw(\"cast\"), \"import\": kw(\"import\"), \"macro\": kw(\"macro\"),\n    \"function\": kw(\"function\"), \"catch\": kw(\"catch\"), \"untyped\": kw(\"untyped\"), \"callback\": kw(\"cb\"),\n    \"for\": kw(\"for\"), \"switch\": kw(\"switch\"), \"case\": kw(\"case\"), \"default\": kw(\"default\"),\n    \"in\": operator, \"never\": kw(\"property_access\"), \"trace\":kw(\"trace\"),\n    \"class\": type, \"abstract\":type, \"enum\":type, \"interface\":type, \"typedef\":type, \"extends\":type, \"implements\":type, \"dynamic\":type,\n    \"true\": atom, \"false\": atom, \"null\": atom\n  };\n\n  var isOperatorChar = /[+\\-*&%=<>!?|]/;\n\n  function chain(stream, state, f) {\n    state.tokenize = f;\n    return f(stream, state);\n  }\n\n  function toUnescaped(stream, end) {\n    var escaped = false, next;\n    while ((next = stream.next()) != null) {\n      if (next == end && !escaped)\n        return true;\n      escaped = !escaped && next == \"\\\\\";\n    }\n  }\n\n  // Used as scratch variables to communicate multiple values without\n  // consing up tons of objects.\n  var type, content;\n  function ret(tp, style, cont) {\n    type = tp; content = cont;\n    return style;\n  }\n\n  function haxeTokenBase(stream, state) {\n    var ch = stream.next();\n    if (ch == '\"' || ch == \"'\") {\n      return chain(stream, state, haxeTokenString(ch));\n    } else if (/[\\[\\]{}\\(\\),;\\:\\.]/.test(ch)) {\n      return ret(ch);\n    } else if (ch == \"0\" && stream.eat(/x/i)) {\n      stream.eatWhile(/[\\da-f]/i);\n      return ret(\"number\", \"number\");\n    } else if (/\\d/.test(ch) || ch == \"-\" && stream.eat(/\\d/)) {\n      stream.match(/^\\d*(?:\\.\\d*(?!\\.))?(?:[eE][+\\-]?\\d+)?/);\n      return ret(\"number\", \"number\");\n    } else if (state.reAllowed && (ch == \"~\" && stream.eat(/\\//))) {\n      toUnescaped(stream, \"/\");\n      stream.eatWhile(/[gimsu]/);\n      return ret(\"regexp\", \"string-2\");\n    } else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        return chain(stream, state, haxeTokenComment);\n      } else if (stream.eat(\"/\")) {\n        stream.skipToEnd();\n        return ret(\"comment\", \"comment\");\n      } else {\n        stream.eatWhile(isOperatorChar);\n        return ret(\"operator\", null, stream.current());\n      }\n    } else if (ch == \"#\") {\n        stream.skipToEnd();\n        return ret(\"conditional\", \"meta\");\n    } else if (ch == \"@\") {\n      stream.eat(/:/);\n      stream.eatWhile(/[\\w_]/);\n      return ret (\"metadata\", \"meta\");\n    } else if (isOperatorChar.test(ch)) {\n      stream.eatWhile(isOperatorChar);\n      return ret(\"operator\", null, stream.current());\n    } else {\n      var word;\n      if(/[A-Z]/.test(ch)) {\n        stream.eatWhile(/[\\w_<>]/);\n        word = stream.current();\n        return ret(\"type\", \"variable-3\", word);\n      } else {\n        stream.eatWhile(/[\\w_]/);\n        var word = stream.current(), known = keywords.propertyIsEnumerable(word) && keywords[word];\n        return (known && state.kwAllowed) ? ret(known.type, known.style, word) :\n                       ret(\"variable\", \"variable\", word);\n      }\n    }\n  }\n\n  function haxeTokenString(quote) {\n    return function(stream, state) {\n      if (toUnescaped(stream, quote))\n        state.tokenize = haxeTokenBase;\n      return ret(\"string\", \"string\");\n    };\n  }\n\n  function haxeTokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = haxeTokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return ret(\"comment\", \"comment\");\n  }\n\n  // Parser\n\n  var atomicTypes = {\"atom\": true, \"number\": true, \"variable\": true, \"string\": true, \"regexp\": true};\n\n  function HaxeLexical(indented, column, type, align, prev, info) {\n    this.indented = indented;\n    this.column = column;\n    this.type = type;\n    this.prev = prev;\n    this.info = info;\n    if (align != null) this.align = align;\n  }\n\n  function inScope(state, varname) {\n    for (var v = state.localVars; v; v = v.next)\n      if (v.name == varname) return true;\n  }\n\n  function parseHaxe(state, style, type, content, stream) {\n    var cc = state.cc;\n    // Communicate our context to the combinators.\n    // (Less wasteful than consing up a hundred closures on every call.)\n    cx.state = state; cx.stream = stream; cx.marked = null, cx.cc = cc;\n\n    if (!state.lexical.hasOwnProperty(\"align\"))\n      state.lexical.align = true;\n\n    while(true) {\n      var combinator = cc.length ? cc.pop() : statement;\n      if (combinator(type, content)) {\n        while(cc.length && cc[cc.length - 1].lex)\n          cc.pop()();\n        if (cx.marked) return cx.marked;\n        if (type == \"variable\" && inScope(state, content)) return \"variable-2\";\n        if (type == \"variable\" && imported(state, content)) return \"variable-3\";\n        return style;\n      }\n    }\n  }\n\n  function imported(state, typename) {\n    if (/[a-z]/.test(typename.charAt(0)))\n      return false;\n    var len = state.importedtypes.length;\n    for (var i = 0; i<len; i++)\n      if(state.importedtypes[i]==typename) return true;\n  }\n\n  function registerimport(importname) {\n    var state = cx.state;\n    for (var t = state.importedtypes; t; t = t.next)\n      if(t.name == importname) return;\n    state.importedtypes = { name: importname, next: state.importedtypes };\n  }\n  // Combinator utils\n\n  var cx = {state: null, column: null, marked: null, cc: null};\n  function pass() {\n    for (var i = arguments.length - 1; i >= 0; i--) cx.cc.push(arguments[i]);\n  }\n  function cont() {\n    pass.apply(null, arguments);\n    return true;\n  }\n  function inList(name, list) {\n    for (var v = list; v; v = v.next)\n      if (v.name == name) return true;\n    return false;\n  }\n  function register(varname) {\n    var state = cx.state;\n    if (state.context) {\n      cx.marked = \"def\";\n      if (inList(varname, state.localVars)) return;\n      state.localVars = {name: varname, next: state.localVars};\n    } else if (state.globalVars) {\n      if (inList(varname, state.globalVars)) return;\n      state.globalVars = {name: varname, next: state.globalVars};\n    }\n  }\n\n  // Combinators\n\n  var defaultVars = {name: \"this\", next: null};\n  function pushcontext() {\n    if (!cx.state.context) cx.state.localVars = defaultVars;\n    cx.state.context = {prev: cx.state.context, vars: cx.state.localVars};\n  }\n  function popcontext() {\n    cx.state.localVars = cx.state.context.vars;\n    cx.state.context = cx.state.context.prev;\n  }\n  popcontext.lex = true;\n  function pushlex(type, info) {\n    var result = function() {\n      var state = cx.state;\n      state.lexical = new HaxeLexical(state.indented, cx.stream.column(), type, null, state.lexical, info);\n    };\n    result.lex = true;\n    return result;\n  }\n  function poplex() {\n    var state = cx.state;\n    if (state.lexical.prev) {\n      if (state.lexical.type == \")\")\n        state.indented = state.lexical.indented;\n      state.lexical = state.lexical.prev;\n    }\n  }\n  poplex.lex = true;\n\n  function expect(wanted) {\n    function f(type) {\n      if (type == wanted) return cont();\n      else if (wanted == \";\") return pass();\n      else return cont(f);\n    }\n    return f;\n  }\n\n  function statement(type) {\n    if (type == \"@\") return cont(metadef);\n    if (type == \"var\") return cont(pushlex(\"vardef\"), vardef1, expect(\";\"), poplex);\n    if (type == \"keyword a\") return cont(pushlex(\"form\"), expression, statement, poplex);\n    if (type == \"keyword b\") return cont(pushlex(\"form\"), statement, poplex);\n    if (type == \"{\") return cont(pushlex(\"}\"), pushcontext, block, poplex, popcontext);\n    if (type == \";\") return cont();\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"for\") return cont(pushlex(\"form\"), expect(\"(\"), pushlex(\")\"), forspec1, expect(\")\"),\n                                   poplex, statement, poplex);\n    if (type == \"variable\") return cont(pushlex(\"stat\"), maybelabel);\n    if (type == \"switch\") return cont(pushlex(\"form\"), expression, pushlex(\"}\", \"switch\"), expect(\"{\"),\n                                      block, poplex, poplex);\n    if (type == \"case\") return cont(expression, expect(\":\"));\n    if (type == \"default\") return cont(expect(\":\"));\n    if (type == \"catch\") return cont(pushlex(\"form\"), pushcontext, expect(\"(\"), funarg, expect(\")\"),\n                                     statement, poplex, popcontext);\n    if (type == \"import\") return cont(importdef, expect(\";\"));\n    if (type == \"typedef\") return cont(typedef);\n    return pass(pushlex(\"stat\"), expression, expect(\";\"), poplex);\n  }\n  function expression(type) {\n    if (atomicTypes.hasOwnProperty(type)) return cont(maybeoperator);\n    if (type == \"type\" ) return cont(maybeoperator);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"keyword c\") return cont(maybeexpression);\n    if (type == \"(\") return cont(pushlex(\")\"), maybeexpression, expect(\")\"), poplex, maybeoperator);\n    if (type == \"operator\") return cont(expression);\n    if (type == \"[\") return cont(pushlex(\"]\"), commasep(maybeexpression, \"]\"), poplex, maybeoperator);\n    if (type == \"{\") return cont(pushlex(\"}\"), commasep(objprop, \"}\"), poplex, maybeoperator);\n    return cont();\n  }\n  function maybeexpression(type) {\n    if (type.match(/[;\\}\\)\\],]/)) return pass();\n    return pass(expression);\n  }\n\n  function maybeoperator(type, value) {\n    if (type == \"operator\" && /\\+\\+|--/.test(value)) return cont(maybeoperator);\n    if (type == \"operator\" || type == \":\") return cont(expression);\n    if (type == \";\") return;\n    if (type == \"(\") return cont(pushlex(\")\"), commasep(expression, \")\"), poplex, maybeoperator);\n    if (type == \".\") return cont(property, maybeoperator);\n    if (type == \"[\") return cont(pushlex(\"]\"), expression, expect(\"]\"), poplex, maybeoperator);\n  }\n\n  function maybeattribute(type) {\n    if (type == \"attribute\") return cont(maybeattribute);\n    if (type == \"function\") return cont(functiondef);\n    if (type == \"var\") return cont(vardef1);\n  }\n\n  function metadef(type) {\n    if(type == \":\") return cont(metadef);\n    if(type == \"variable\") return cont(metadef);\n    if(type == \"(\") return cont(pushlex(\")\"), commasep(metaargs, \")\"), poplex, statement);\n  }\n  function metaargs(type) {\n    if(type == \"variable\") return cont();\n  }\n\n  function importdef (type, value) {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if(type == \"variable\" || type == \"property\" || type == \".\" || value == \"*\") return cont(importdef);\n  }\n\n  function typedef (type, value)\n  {\n    if(type == \"variable\" && /[A-Z]/.test(value.charAt(0))) { registerimport(value); return cont(); }\n    else if (type == \"type\" && /[A-Z]/.test(value.charAt(0))) { return cont(); }\n  }\n\n  function maybelabel(type) {\n    if (type == \":\") return cont(poplex, statement);\n    return pass(maybeoperator, expect(\";\"), poplex);\n  }\n  function property(type) {\n    if (type == \"variable\") {cx.marked = \"property\"; return cont();}\n  }\n  function objprop(type) {\n    if (type == \"variable\") cx.marked = \"property\";\n    if (atomicTypes.hasOwnProperty(type)) return cont(expect(\":\"), expression);\n  }\n  function commasep(what, end) {\n    function proceed(type) {\n      if (type == \",\") return cont(what, proceed);\n      if (type == end) return cont();\n      return cont(expect(end));\n    }\n    return function(type) {\n      if (type == end) return cont();\n      else return pass(what, proceed);\n    };\n  }\n  function block(type) {\n    if (type == \"}\") return cont();\n    return pass(statement, block);\n  }\n  function vardef1(type, value) {\n    if (type == \"variable\"){register(value); return cont(typeuse, vardef2);}\n    return cont();\n  }\n  function vardef2(type, value) {\n    if (value == \"=\") return cont(expression, vardef2);\n    if (type == \",\") return cont(vardef1);\n  }\n  function forspec1(type, value) {\n    if (type == \"variable\") {\n      register(value);\n      return cont(forin, expression)\n    } else {\n      return pass()\n    }\n  }\n  function forin(_type, value) {\n    if (value == \"in\") return cont();\n  }\n  function functiondef(type, value) {\n    //function names starting with upper-case letters are recognised as types, so cludging them together here.\n    if (type == \"variable\" || type == \"type\") {register(value); return cont(functiondef);}\n    if (value == \"new\") return cont(functiondef);\n    if (type == \"(\") return cont(pushlex(\")\"), pushcontext, commasep(funarg, \")\"), poplex, typeuse, statement, popcontext);\n  }\n  function typeuse(type) {\n    if(type == \":\") return cont(typestring);\n  }\n  function typestring(type) {\n    if(type == \"type\") return cont();\n    if(type == \"variable\") return cont();\n    if(type == \"{\") return cont(pushlex(\"}\"), commasep(typeprop, \"}\"), poplex);\n  }\n  function typeprop(type) {\n    if(type == \"variable\") return cont(typeuse);\n  }\n  function funarg(type, value) {\n    if (type == \"variable\") {register(value); return cont(typeuse);}\n  }\n\n  // Interface\n  return {\n    startState: function(basecolumn) {\n      var defaulttypes = [\"Int\", \"Float\", \"String\", \"Void\", \"Std\", \"Bool\", \"Dynamic\", \"Array\"];\n      var state = {\n        tokenize: haxeTokenBase,\n        reAllowed: true,\n        kwAllowed: true,\n        cc: [],\n        lexical: new HaxeLexical((basecolumn || 0) - indentUnit, 0, \"block\", false),\n        localVars: parserConfig.localVars,\n        importedtypes: defaulttypes,\n        context: parserConfig.localVars && {vars: parserConfig.localVars},\n        indented: 0\n      };\n      if (parserConfig.globalVars && typeof parserConfig.globalVars == \"object\")\n        state.globalVars = parserConfig.globalVars;\n      return state;\n    },\n\n    token: function(stream, state) {\n      if (stream.sol()) {\n        if (!state.lexical.hasOwnProperty(\"align\"))\n          state.lexical.align = false;\n        state.indented = stream.indentation();\n      }\n      if (stream.eatSpace()) return null;\n      var style = state.tokenize(stream, state);\n      if (type == \"comment\") return style;\n      state.reAllowed = !!(type == \"operator\" || type == \"keyword c\" || type.match(/^[\\[{}\\(,;:]$/));\n      state.kwAllowed = type != '.';\n      return parseHaxe(state, style, type, content, stream);\n    },\n\n    indent: function(state, textAfter) {\n      if (state.tokenize != haxeTokenBase) return 0;\n      var firstChar = textAfter && textAfter.charAt(0), lexical = state.lexical;\n      if (lexical.type == \"stat\" && firstChar == \"}\") lexical = lexical.prev;\n      var type = lexical.type, closing = firstChar == type;\n      if (type == \"vardef\") return lexical.indented + 4;\n      else if (type == \"form\" && firstChar == \"{\") return lexical.indented;\n      else if (type == \"stat\" || type == \"form\") return lexical.indented + indentUnit;\n      else if (lexical.info == \"switch\" && !closing)\n        return lexical.indented + (/^(?:case|default)\\b/.test(textAfter) ? indentUnit : 2 * indentUnit);\n      else if (lexical.align) return lexical.column + (closing ? 0 : 1);\n      else return lexical.indented + (closing ? 0 : indentUnit);\n    },\n\n    electricChars: \"{}\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\",\n    lineComment: \"//\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-haxe\", \"haxe\");\n\nCodeMirror.defineMode(\"hxml\", function () {\n\n  return {\n    startState: function () {\n      return {\n        define: false,\n        inString: false\n      };\n    },\n    token: function (stream, state) {\n      var ch = stream.peek();\n      var sol = stream.sol();\n\n      ///* comments */\n      if (ch == \"#\") {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      if (sol && ch == \"-\") {\n        var style = \"variable-2\";\n\n        stream.eat(/-/);\n\n        if (stream.peek() == \"-\") {\n          stream.eat(/-/);\n          style = \"keyword a\";\n        }\n\n        if (stream.peek() == \"D\") {\n          stream.eat(/[D]/);\n          style = \"keyword c\";\n          state.define = true;\n        }\n\n        stream.eatWhile(/[A-Z]/i);\n        return style;\n      }\n\n      var ch = stream.peek();\n\n      if (state.inString == false && ch == \"'\") {\n        state.inString = true;\n        stream.next();\n      }\n\n      if (state.inString == true) {\n        if (stream.skipTo(\"'\")) {\n\n        } else {\n          stream.skipToEnd();\n        }\n\n        if (stream.peek() == \"'\") {\n          stream.next();\n          state.inString = false;\n        }\n\n        return \"string\";\n      }\n\n      stream.next();\n      return null;\n    },\n    lineComment: \"#\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-hxml\", \"hxml\");\n\n});\n"]},"metadata":{},"sourceType":"script"}