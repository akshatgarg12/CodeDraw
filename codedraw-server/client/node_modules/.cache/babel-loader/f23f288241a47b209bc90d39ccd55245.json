{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../javascript/javascript\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\"; // Depth means the amount of open braces in JS context, in XML\n  // context 0 means not in tag, 1 means in tag, and 2 means in tag\n  // and js block comment.\n\n  function Context(state, mode, depth, prev) {\n    this.state = state;\n    this.mode = mode;\n    this.depth = depth;\n    this.prev = prev;\n  }\n\n  function copyContext(context) {\n    return new Context(CodeMirror.copyState(context.mode, context.state), context.mode, context.depth, context.prev && copyContext(context.prev));\n  }\n\n  CodeMirror.defineMode(\"jsx\", function (config, modeConfig) {\n    var xmlMode = CodeMirror.getMode(config, {\n      name: \"xml\",\n      allowMissing: true,\n      multilineTagIndentPastTag: false,\n      allowMissingTagName: true\n    });\n    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || \"javascript\");\n\n    function flatXMLIndent(state) {\n      var tagName = state.tagName;\n      state.tagName = null;\n      var result = xmlMode.indent(state, \"\", \"\");\n      state.tagName = tagName;\n      return result;\n    }\n\n    function token(stream, state) {\n      if (state.context.mode == xmlMode) return xmlToken(stream, state, state.context);else return jsToken(stream, state, state.context);\n    }\n\n    function xmlToken(stream, state, cx) {\n      if (cx.depth == 2) {\n        // Inside a JS /* */ comment\n        if (stream.match(/^.*?\\*\\//)) cx.depth = 1;else stream.skipToEnd();\n        return \"comment\";\n      }\n\n      if (stream.peek() == \"{\") {\n        xmlMode.skipAttribute(cx.state);\n        var indent = flatXMLIndent(cx.state),\n            xmlContext = cx.state.context; // If JS starts on same line as tag\n\n        if (xmlContext && stream.match(/^[^>]*>\\s*$/, false)) {\n          while (xmlContext.prev && !xmlContext.startOfLine) xmlContext = xmlContext.prev; // If tag starts the line, use XML indentation level\n\n\n          if (xmlContext.startOfLine) indent -= config.indentUnit; // Else use JS indentation level\n          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented; // Else if inside of tag\n        } else if (cx.depth == 1) {\n          indent += config.indentUnit;\n        }\n\n        state.context = new Context(CodeMirror.startState(jsMode, indent), jsMode, 0, state.context);\n        return null;\n      }\n\n      if (cx.depth == 1) {\n        // Inside of tag\n        if (stream.peek() == \"<\") {\n          // Tag inside of tag\n          xmlMode.skipAttribute(cx.state);\n          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)), xmlMode, 0, state.context);\n          return null;\n        } else if (stream.match(\"//\")) {\n          stream.skipToEnd();\n          return \"comment\";\n        } else if (stream.match(\"/*\")) {\n          cx.depth = 2;\n          return token(stream, state);\n        }\n      }\n\n      var style = xmlMode.token(stream, cx.state),\n          cur = stream.current(),\n          stop;\n\n      if (/\\btag\\b/.test(style)) {\n        if (/>$/.test(cur)) {\n          if (cx.state.context) cx.depth = 0;else state.context = state.context.prev;\n        } else if (/^</.test(cur)) {\n          cx.depth = 1;\n        }\n      } else if (!style && (stop = cur.indexOf(\"{\")) > -1) {\n        stream.backUp(cur.length - stop);\n      }\n\n      return style;\n    }\n\n    function jsToken(stream, state, cx) {\n      if (stream.peek() == \"<\" && jsMode.expressionAllowed(stream, cx.state)) {\n        jsMode.skipExpression(cx.state);\n        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, \"\", \"\")), xmlMode, 0, state.context);\n        return null;\n      }\n\n      var style = jsMode.token(stream, cx.state);\n\n      if (!style && cx.depth != null) {\n        var cur = stream.current();\n\n        if (cur == \"{\") {\n          cx.depth++;\n        } else if (cur == \"}\") {\n          if (--cx.depth == 0) state.context = state.context.prev;\n        }\n      }\n\n      return style;\n    }\n\n    return {\n      startState: function () {\n        return {\n          context: new Context(CodeMirror.startState(jsMode), jsMode)\n        };\n      },\n      copyState: function (state) {\n        return {\n          context: copyContext(state.context)\n        };\n      },\n      token: token,\n      indent: function (state, textAfter, fullLine) {\n        return state.context.mode.indent(state.context.state, textAfter, fullLine);\n      },\n      innerMode: function (state) {\n        return state.context;\n      }\n    };\n  }, \"xml\", \"javascript\");\n  CodeMirror.defineMIME(\"text/jsx\", \"jsx\");\n  CodeMirror.defineMIME(\"text/typescript-jsx\", {\n    name: \"jsx\",\n    base: {\n      name: \"javascript\",\n      typescript: true\n    }\n  });\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/jsx/jsx.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","Context","state","mode","depth","prev","copyContext","context","copyState","defineMode","config","modeConfig","xmlMode","getMode","name","allowMissing","multilineTagIndentPastTag","allowMissingTagName","jsMode","base","flatXMLIndent","tagName","result","indent","token","stream","xmlToken","jsToken","cx","match","skipToEnd","peek","skipAttribute","xmlContext","startOfLine","indentUnit","lexical","indented","startState","style","cur","current","stop","test","indexOf","backUp","length","expressionAllowed","skipExpression","textAfter","fullLine","innerMode","defineMIME","typescript"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../xml/xml\"), require(\"../javascript/javascript\"))\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../xml/xml\", \"../javascript/javascript\"], mod)\n  else // Plain browser env\n    mod(CodeMirror)\n})(function(CodeMirror) {\n  \"use strict\"\n\n  // Depth means the amount of open braces in JS context, in XML\n  // context 0 means not in tag, 1 means in tag, and 2 means in tag\n  // and js block comment.\n  function Context(state, mode, depth, prev) {\n    this.state = state; this.mode = mode; this.depth = depth; this.prev = prev\n  }\n\n  function copyContext(context) {\n    return new Context(CodeMirror.copyState(context.mode, context.state),\n                       context.mode,\n                       context.depth,\n                       context.prev && copyContext(context.prev))\n  }\n\n  CodeMirror.defineMode(\"jsx\", function(config, modeConfig) {\n    var xmlMode = CodeMirror.getMode(config, {name: \"xml\", allowMissing: true, multilineTagIndentPastTag: false, allowMissingTagName: true})\n    var jsMode = CodeMirror.getMode(config, modeConfig && modeConfig.base || \"javascript\")\n\n    function flatXMLIndent(state) {\n      var tagName = state.tagName\n      state.tagName = null\n      var result = xmlMode.indent(state, \"\", \"\")\n      state.tagName = tagName\n      return result\n    }\n\n    function token(stream, state) {\n      if (state.context.mode == xmlMode)\n        return xmlToken(stream, state, state.context)\n      else\n        return jsToken(stream, state, state.context)\n    }\n\n    function xmlToken(stream, state, cx) {\n      if (cx.depth == 2) { // Inside a JS /* */ comment\n        if (stream.match(/^.*?\\*\\//)) cx.depth = 1\n        else stream.skipToEnd()\n        return \"comment\"\n      }\n\n      if (stream.peek() == \"{\") {\n        xmlMode.skipAttribute(cx.state)\n\n        var indent = flatXMLIndent(cx.state), xmlContext = cx.state.context\n        // If JS starts on same line as tag\n        if (xmlContext && stream.match(/^[^>]*>\\s*$/, false)) {\n          while (xmlContext.prev && !xmlContext.startOfLine)\n            xmlContext = xmlContext.prev\n          // If tag starts the line, use XML indentation level\n          if (xmlContext.startOfLine) indent -= config.indentUnit\n          // Else use JS indentation level\n          else if (cx.prev.state.lexical) indent = cx.prev.state.lexical.indented\n        // Else if inside of tag\n        } else if (cx.depth == 1) {\n          indent += config.indentUnit\n        }\n\n        state.context = new Context(CodeMirror.startState(jsMode, indent),\n                                    jsMode, 0, state.context)\n        return null\n      }\n\n      if (cx.depth == 1) { // Inside of tag\n        if (stream.peek() == \"<\") { // Tag inside of tag\n          xmlMode.skipAttribute(cx.state)\n          state.context = new Context(CodeMirror.startState(xmlMode, flatXMLIndent(cx.state)),\n                                      xmlMode, 0, state.context)\n          return null\n        } else if (stream.match(\"//\")) {\n          stream.skipToEnd()\n          return \"comment\"\n        } else if (stream.match(\"/*\")) {\n          cx.depth = 2\n          return token(stream, state)\n        }\n      }\n\n      var style = xmlMode.token(stream, cx.state), cur = stream.current(), stop\n      if (/\\btag\\b/.test(style)) {\n        if (/>$/.test(cur)) {\n          if (cx.state.context) cx.depth = 0\n          else state.context = state.context.prev\n        } else if (/^</.test(cur)) {\n          cx.depth = 1\n        }\n      } else if (!style && (stop = cur.indexOf(\"{\")) > -1) {\n        stream.backUp(cur.length - stop)\n      }\n      return style\n    }\n\n    function jsToken(stream, state, cx) {\n      if (stream.peek() == \"<\" && jsMode.expressionAllowed(stream, cx.state)) {\n        jsMode.skipExpression(cx.state)\n        state.context = new Context(CodeMirror.startState(xmlMode, jsMode.indent(cx.state, \"\", \"\")),\n                                    xmlMode, 0, state.context)\n        return null\n      }\n\n      var style = jsMode.token(stream, cx.state)\n      if (!style && cx.depth != null) {\n        var cur = stream.current()\n        if (cur == \"{\") {\n          cx.depth++\n        } else if (cur == \"}\") {\n          if (--cx.depth == 0) state.context = state.context.prev\n        }\n      }\n      return style\n    }\n\n    return {\n      startState: function() {\n        return {context: new Context(CodeMirror.startState(jsMode), jsMode)}\n      },\n\n      copyState: function(state) {\n        return {context: copyContext(state.context)}\n      },\n\n      token: token,\n\n      indent: function(state, textAfter, fullLine) {\n        return state.context.mode.indent(state.context.state, textAfter, fullLine)\n      },\n\n      innerMode: function(state) {\n        return state.context\n      }\n    }\n  }, \"xml\", \"javascript\")\n\n  CodeMirror.defineMIME(\"text/jsx\", \"jsx\")\n  CodeMirror.defineMIME(\"text/typescript-jsx\", {name: \"jsx\", base: {name: \"javascript\", typescript: true}})\n});\n"]},"metadata":{},"sourceType":"script"}