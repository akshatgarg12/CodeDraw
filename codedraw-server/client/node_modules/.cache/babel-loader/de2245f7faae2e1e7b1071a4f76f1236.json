{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  CodeMirror.defineMode(\"oz\", function (conf) {\n    function wordRegexp(words) {\n      return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n    }\n\n    var singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\n    var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\n    var tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n    var middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\", \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\n    var end = [\"end\"];\n    var atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\n    var commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\", \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\n    var openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\", \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\n    var middleKeywords = wordRegexp(middle);\n    var endKeywords = wordRegexp(end); // Tokenizers\n\n    function tokenBase(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      } // Brackets\n\n\n      if (stream.match(/[{}]/)) {\n        return \"bracket\";\n      } // Special [] keyword\n\n\n      if (stream.match(/(\\[])/)) {\n        return \"keyword\";\n      } // Operators\n\n\n      if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n        return \"operator\";\n      } // Atoms\n\n\n      if (stream.match(atoms)) {\n        return 'atom';\n      } // Opening keywords\n\n\n      var matched = stream.match(openingKeywords);\n\n      if (matched) {\n        if (!state.doInCurrentLine) state.currentIndent++;else state.doInCurrentLine = false; // Special matching for signatures\n\n        if (matched[0] == \"proc\" || matched[0] == \"fun\") state.tokenize = tokenFunProc;else if (matched[0] == \"class\") state.tokenize = tokenClass;else if (matched[0] == \"meth\") state.tokenize = tokenMeth;\n        return 'keyword';\n      } // Middle and other keywords\n\n\n      if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n        return \"keyword\";\n      } // End keywords\n\n\n      if (stream.match(endKeywords)) {\n        state.currentIndent--;\n        return 'keyword';\n      } // Eat the next char for next comparisons\n\n\n      var ch = stream.next(); // Strings\n\n      if (ch == '\"' || ch == \"'\") {\n        state.tokenize = tokenString(ch);\n        return state.tokenize(stream, state);\n      } // Numbers\n\n\n      if (/[~\\d]/.test(ch)) {\n        if (ch == \"~\") {\n          if (!/^[0-9]/.test(stream.peek())) return null;else if (stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        }\n\n        if (ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/)) return \"number\";\n        return null;\n      } // Comments\n\n\n      if (ch == \"%\") {\n        stream.skipToEnd();\n        return 'comment';\n      } else if (ch == \"/\") {\n        if (stream.eat(\"*\")) {\n          state.tokenize = tokenComment;\n          return tokenComment(stream, state);\n        }\n      } // Single operators\n\n\n      if (singleOperators.test(ch)) {\n        return \"operator\";\n      } // If nothing match, we skip the entire alphanumerical block\n\n\n      stream.eatWhile(/\\w/);\n      return \"variable\";\n    }\n\n    function tokenClass(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n      state.tokenize = tokenBase;\n      return \"variable-3\";\n    }\n\n    function tokenMeth(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n      state.tokenize = tokenBase;\n      return \"def\";\n    }\n\n    function tokenFunProc(stream, state) {\n      if (stream.eatSpace()) {\n        return null;\n      }\n\n      if (!state.hasPassedFirstStage && stream.eat(\"{\")) {\n        state.hasPassedFirstStage = true;\n        return \"bracket\";\n      } else if (state.hasPassedFirstStage) {\n        stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n        state.hasPassedFirstStage = false;\n        state.tokenize = tokenBase;\n        return \"def\";\n      } else {\n        state.tokenize = tokenBase;\n        return null;\n      }\n    }\n\n    function tokenComment(stream, state) {\n      var maybeEnd = false,\n          ch;\n\n      while (ch = stream.next()) {\n        if (ch == \"/\" && maybeEnd) {\n          state.tokenize = tokenBase;\n          break;\n        }\n\n        maybeEnd = ch == \"*\";\n      }\n\n      return \"comment\";\n    }\n\n    function tokenString(quote) {\n      return function (stream, state) {\n        var escaped = false,\n            next,\n            end = false;\n\n        while ((next = stream.next()) != null) {\n          if (next == quote && !escaped) {\n            end = true;\n            break;\n          }\n\n          escaped = !escaped && next == \"\\\\\";\n        }\n\n        if (end || !escaped) state.tokenize = tokenBase;\n        return \"string\";\n      };\n    }\n\n    function buildElectricInputRegEx() {\n      // Reindentation should occur on [] or on a match of any of\n      // the block closing keywords, at the end of a line.\n      var allClosings = middle.concat(end);\n      return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n    }\n\n    return {\n      startState: function () {\n        return {\n          tokenize: tokenBase,\n          currentIndent: 0,\n          doInCurrentLine: false,\n          hasPassedFirstStage: false\n        };\n      },\n      token: function (stream, state) {\n        if (stream.sol()) state.doInCurrentLine = 0;\n        return state.tokenize(stream, state);\n      },\n      indent: function (state, textAfter) {\n        var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n        if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/)) return conf.indentUnit * (state.currentIndent - 1);\n        if (state.currentIndent < 0) return 0;\n        return state.currentIndent * conf.indentUnit;\n      },\n      fold: \"indent\",\n      electricInput: buildElectricInputRegEx(),\n      lineComment: \"%\",\n      blockCommentStart: \"/*\",\n      blockCommentEnd: \"*/\"\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-oz\", \"oz\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/oz/oz.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","conf","wordRegexp","words","RegExp","join","singleOperators","doubleOperators","tripleOperators","middle","end","atoms","commonKeywords","openingKeywords","middleKeywords","endKeywords","tokenBase","stream","state","eatSpace","match","matched","doInCurrentLine","currentIndent","tokenize","tokenFunProc","tokenClass","tokenMeth","ch","next","tokenString","test","peek","skipToEnd","eat","tokenComment","eatWhile","hasPassedFirstStage","maybeEnd","quote","escaped","buildElectricInputRegEx","allClosings","concat","startState","token","sol","indent","textAfter","trueText","replace","indentUnit","fold","electricInput","lineComment","blockCommentStart","blockCommentEnd","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nCodeMirror.defineMode(\"oz\", function (conf) {\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  var singleOperators = /[\\^@!\\|<>#~\\.\\*\\-\\+\\\\/,=]/;\n  var doubleOperators = /(<-)|(:=)|(=<)|(>=)|(<=)|(<:)|(>:)|(=:)|(\\\\=)|(\\\\=:)|(!!)|(==)|(::)/;\n  var tripleOperators = /(:::)|(\\.\\.\\.)|(=<:)|(>=:)/;\n\n  var middle = [\"in\", \"then\", \"else\", \"of\", \"elseof\", \"elsecase\", \"elseif\", \"catch\",\n    \"finally\", \"with\", \"require\", \"prepare\", \"import\", \"export\", \"define\", \"do\"];\n  var end = [\"end\"];\n\n  var atoms = wordRegexp([\"true\", \"false\", \"nil\", \"unit\"]);\n  var commonKeywords = wordRegexp([\"andthen\", \"at\", \"attr\", \"declare\", \"feat\", \"from\", \"lex\",\n    \"mod\", \"div\", \"mode\", \"orelse\", \"parser\", \"prod\", \"prop\", \"scanner\", \"self\", \"syn\", \"token\"]);\n  var openingKeywords = wordRegexp([\"local\", \"proc\", \"fun\", \"case\", \"class\", \"if\", \"cond\", \"or\", \"dis\",\n    \"choice\", \"not\", \"thread\", \"try\", \"raise\", \"lock\", \"for\", \"suchthat\", \"meth\", \"functor\"]);\n  var middleKeywords = wordRegexp(middle);\n  var endKeywords = wordRegexp(end);\n\n  // Tokenizers\n  function tokenBase(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    // Brackets\n    if(stream.match(/[{}]/)) {\n      return \"bracket\";\n    }\n\n    // Special [] keyword\n    if (stream.match(/(\\[])/)) {\n        return \"keyword\"\n    }\n\n    // Operators\n    if (stream.match(tripleOperators) || stream.match(doubleOperators)) {\n      return \"operator\";\n    }\n\n    // Atoms\n    if(stream.match(atoms)) {\n      return 'atom';\n    }\n\n    // Opening keywords\n    var matched = stream.match(openingKeywords);\n    if (matched) {\n      if (!state.doInCurrentLine)\n        state.currentIndent++;\n      else\n        state.doInCurrentLine = false;\n\n      // Special matching for signatures\n      if(matched[0] == \"proc\" || matched[0] == \"fun\")\n        state.tokenize = tokenFunProc;\n      else if(matched[0] == \"class\")\n        state.tokenize = tokenClass;\n      else if(matched[0] == \"meth\")\n        state.tokenize = tokenMeth;\n\n      return 'keyword';\n    }\n\n    // Middle and other keywords\n    if (stream.match(middleKeywords) || stream.match(commonKeywords)) {\n      return \"keyword\"\n    }\n\n    // End keywords\n    if (stream.match(endKeywords)) {\n      state.currentIndent--;\n      return 'keyword';\n    }\n\n    // Eat the next char for next comparisons\n    var ch = stream.next();\n\n    // Strings\n    if (ch == '\"' || ch == \"'\") {\n      state.tokenize = tokenString(ch);\n      return state.tokenize(stream, state);\n    }\n\n    // Numbers\n    if (/[~\\d]/.test(ch)) {\n      if (ch == \"~\") {\n        if(! /^[0-9]/.test(stream.peek()))\n          return null;\n        else if (( stream.next() == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n          return \"number\";\n      }\n\n      if ((ch == \"0\" && stream.match(/^[xX][0-9a-fA-F]+/)) || stream.match(/^[0-9]*(\\.[0-9]+)?([eE][~+]?[0-9]+)?/))\n        return \"number\";\n\n      return null;\n    }\n\n    // Comments\n    if (ch == \"%\") {\n      stream.skipToEnd();\n      return 'comment';\n    }\n    else if (ch == \"/\") {\n      if (stream.eat(\"*\")) {\n        state.tokenize = tokenComment;\n        return tokenComment(stream, state);\n      }\n    }\n\n    // Single operators\n    if(singleOperators.test(ch)) {\n      return \"operator\";\n    }\n\n    // If nothing match, we skip the entire alphanumerical block\n    stream.eatWhile(/\\w/);\n\n    return \"variable\";\n  }\n\n  function tokenClass(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n    stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = tokenBase;\n    return \"variable-3\"\n  }\n\n  function tokenMeth(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n    stream.match(/([a-zA-Z][A-Za-z0-9_]*)|(`.+`)/);\n    state.tokenize = tokenBase;\n    return \"def\"\n  }\n\n  function tokenFunProc(stream, state) {\n    if (stream.eatSpace()) {\n      return null;\n    }\n\n    if(!state.hasPassedFirstStage && stream.eat(\"{\")) {\n      state.hasPassedFirstStage = true;\n      return \"bracket\";\n    }\n    else if(state.hasPassedFirstStage) {\n      stream.match(/([A-Z][A-Za-z0-9_]*)|(`.+`)|\\$/);\n      state.hasPassedFirstStage = false;\n      state.tokenize = tokenBase;\n      return \"def\"\n    }\n    else {\n      state.tokenize = tokenBase;\n      return null;\n    }\n  }\n\n  function tokenComment(stream, state) {\n    var maybeEnd = false, ch;\n    while (ch = stream.next()) {\n      if (ch == \"/\" && maybeEnd) {\n        state.tokenize = tokenBase;\n        break;\n      }\n      maybeEnd = (ch == \"*\");\n    }\n    return \"comment\";\n  }\n\n  function tokenString(quote) {\n    return function (stream, state) {\n      var escaped = false, next, end = false;\n      while ((next = stream.next()) != null) {\n        if (next == quote && !escaped) {\n          end = true;\n          break;\n        }\n        escaped = !escaped && next == \"\\\\\";\n      }\n      if (end || !escaped)\n        state.tokenize = tokenBase;\n      return \"string\";\n    };\n  }\n\n  function buildElectricInputRegEx() {\n    // Reindentation should occur on [] or on a match of any of\n    // the block closing keywords, at the end of a line.\n    var allClosings = middle.concat(end);\n    return new RegExp(\"[\\\\[\\\\]]|(\" + allClosings.join(\"|\") + \")$\");\n  }\n\n  return {\n\n    startState: function () {\n      return {\n        tokenize: tokenBase,\n        currentIndent: 0,\n        doInCurrentLine: false,\n        hasPassedFirstStage: false\n      };\n    },\n\n    token: function (stream, state) {\n      if (stream.sol())\n        state.doInCurrentLine = 0;\n\n      return state.tokenize(stream, state);\n    },\n\n    indent: function (state, textAfter) {\n      var trueText = textAfter.replace(/^\\s+|\\s+$/g, '');\n\n      if (trueText.match(endKeywords) || trueText.match(middleKeywords) || trueText.match(/(\\[])/))\n        return conf.indentUnit * (state.currentIndent - 1);\n\n      if (state.currentIndent < 0)\n        return 0;\n\n      return state.currentIndent * conf.indentUnit;\n    },\n    fold: \"indent\",\n    electricInput: buildElectricInputRegEx(),\n    lineComment: \"%\",\n    blockCommentStart: \"/*\",\n    blockCommentEnd: \"*/\"\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-oz\", \"oz\");\n\n});\n"]},"metadata":{},"sourceType":"script"}