{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\"; // full haml mode. This handled embedded ruby and html fragments too\n\n  CodeMirror.defineMode(\"haml\", function (config) {\n    var htmlMode = CodeMirror.getMode(config, {\n      name: \"htmlmixed\"\n    });\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n\n    function rubyInQuote(endQuote) {\n      return function (stream, state) {\n        var ch = stream.peek();\n\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = html;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n\n    function ruby(stream, state) {\n      if (stream.match(\"-#\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function html(stream, state) {\n      var ch = stream.peek(); // handle haml declarations. All declarations that cant be handled here\n      // will be passed to html mode\n\n      if (state.previousToken.style == \"comment\") {\n        if (state.indented > state.previousToken.indented) {\n          stream.skipToEnd();\n          return \"commentLine\";\n        }\n      }\n\n      if (state.startOfLine) {\n        if (ch == \"!\" && stream.match(\"!!\")) {\n          stream.skipToEnd();\n          return \"tag\";\n        } else if (stream.match(/^%[\\w:#\\.]+=/)) {\n          state.tokenize = ruby;\n          return \"hamlTag\";\n        } else if (stream.match(/^%[\\w:]+/)) {\n          return \"hamlTag\";\n        } else if (ch == \"/\") {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (state.startOfLine || state.previousToken.style == \"hamlTag\") {\n        if (ch == \"#\" || ch == \".\") {\n          stream.match(/[\\w-#\\.]*/);\n          return \"hamlAttribute\";\n        }\n      } // donot handle --> as valid ruby, make it HTML close comment instead\n\n\n      if (state.startOfLine && !stream.match(\"-->\", false) && (ch == \"=\" || ch == \"-\")) {\n        state.tokenize = ruby;\n        return state.tokenize(stream, state);\n      }\n\n      if (state.previousToken.style == \"hamlTag\" || state.previousToken.style == \"closeAttributeTag\" || state.previousToken.style == \"hamlAttribute\") {\n        if (ch == \"(\") {\n          state.tokenize = rubyInQuote(\")\");\n          return state.tokenize(stream, state);\n        } else if (ch == \"{\") {\n          if (!stream.match(/^\\{%.*/)) {\n            state.tokenize = rubyInQuote(\"}\");\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n\n      return htmlMode.token(stream, state.htmlState);\n    }\n\n    return {\n      // default to html mode\n      startState: function startState() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          indented: 0,\n          previousToken: {\n            style: null,\n            indented: 0\n          },\n          tokenize: html\n        };\n      },\n      copyState: function copyState(state) {\n        return {\n          htmlState: CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          indented: state.indented,\n          previousToken: state.previousToken,\n          tokenize: state.tokenize\n        };\n      },\n      token: function token(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false; // dont record comment line as we only want to measure comment line with\n        // the opening comment block\n\n        if (style && style != \"commentLine\") {\n          state.previousToken = {\n            style: style,\n            indented: state.indented\n          };\n        } // if current state is ruby and the previous token is not `,` reset the\n        // tokenize to html\n\n\n        if (stream.eol() && state.tokenize == ruby) {\n          stream.backUp(1);\n          var ch = stream.peek();\n          stream.next();\n\n          if (ch && ch != \",\") {\n            state.tokenize = html;\n          }\n        } // reprocess some of the specific style tag when finish setting previousToken\n\n\n        if (style == \"hamlTag\") {\n          style = \"tag\";\n        } else if (style == \"commentLine\") {\n          style = \"comment\";\n        } else if (style == \"hamlAttribute\") {\n          style = \"attribute\";\n        } else if (style == \"closeAttributeTag\") {\n          style = null;\n        }\n\n        return style;\n      }\n    };\n  }, \"htmlmixed\", \"ruby\");\n  CodeMirror.defineMIME(\"text/x-haml\", \"haml\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/haml/haml.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","defineMode","config","htmlMode","getMode","name","rubyMode","rubyInQuote","endQuote","stream","state","ch","peek","rubyState","tokenize","length","next","html","ruby","match","skipToEnd","token","previousToken","style","indented","startOfLine","htmlState","startState","copyState","sol","indentation","eatSpace","eol","backUp","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"), require(\"../htmlmixed/htmlmixed\"), require(\"../ruby/ruby\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\", \"../htmlmixed/htmlmixed\", \"../ruby/ruby\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\n  // full haml mode. This handled embedded ruby and html fragments too\n  CodeMirror.defineMode(\"haml\", function(config) {\n    var htmlMode = CodeMirror.getMode(config, {name: \"htmlmixed\"});\n    var rubyMode = CodeMirror.getMode(config, \"ruby\");\n\n    function rubyInQuote(endQuote) {\n      return function(stream, state) {\n        var ch = stream.peek();\n        if (ch == endQuote && state.rubyState.tokenize.length == 1) {\n          // step out of ruby context as it seems to complete processing all the braces\n          stream.next();\n          state.tokenize = html;\n          return \"closeAttributeTag\";\n        } else {\n          return ruby(stream, state);\n        }\n      };\n    }\n\n    function ruby(stream, state) {\n      if (stream.match(\"-#\")) {\n        stream.skipToEnd();\n        return \"comment\";\n      }\n      return rubyMode.token(stream, state.rubyState);\n    }\n\n    function html(stream, state) {\n      var ch = stream.peek();\n\n      // handle haml declarations. All declarations that cant be handled here\n      // will be passed to html mode\n      if (state.previousToken.style == \"comment\" ) {\n        if (state.indented > state.previousToken.indented) {\n          stream.skipToEnd();\n          return \"commentLine\";\n        }\n      }\n\n      if (state.startOfLine) {\n        if (ch == \"!\" && stream.match(\"!!\")) {\n          stream.skipToEnd();\n          return \"tag\";\n        } else if (stream.match(/^%[\\w:#\\.]+=/)) {\n          state.tokenize = ruby;\n          return \"hamlTag\";\n        } else if (stream.match(/^%[\\w:]+/)) {\n          return \"hamlTag\";\n        } else if (ch == \"/\" ) {\n          stream.skipToEnd();\n          return \"comment\";\n        }\n      }\n\n      if (state.startOfLine || state.previousToken.style == \"hamlTag\") {\n        if ( ch == \"#\" || ch == \".\") {\n          stream.match(/[\\w-#\\.]*/);\n          return \"hamlAttribute\";\n        }\n      }\n\n      // donot handle --> as valid ruby, make it HTML close comment instead\n      if (state.startOfLine && !stream.match(\"-->\", false) && (ch == \"=\" || ch == \"-\" )) {\n        state.tokenize = ruby;\n        return state.tokenize(stream, state);\n      }\n\n      if (state.previousToken.style == \"hamlTag\" ||\n          state.previousToken.style == \"closeAttributeTag\" ||\n          state.previousToken.style == \"hamlAttribute\") {\n        if (ch == \"(\") {\n          state.tokenize = rubyInQuote(\")\");\n          return state.tokenize(stream, state);\n        } else if (ch == \"{\") {\n          if (!stream.match(/^\\{%.*/)) {\n            state.tokenize = rubyInQuote(\"}\");\n            return state.tokenize(stream, state);\n          }\n        }\n      }\n\n      return htmlMode.token(stream, state.htmlState);\n    }\n\n    return {\n      // default to html mode\n      startState: function() {\n        var htmlState = CodeMirror.startState(htmlMode);\n        var rubyState = CodeMirror.startState(rubyMode);\n        return {\n          htmlState: htmlState,\n          rubyState: rubyState,\n          indented: 0,\n          previousToken: { style: null, indented: 0},\n          tokenize: html\n        };\n      },\n\n      copyState: function(state) {\n        return {\n          htmlState : CodeMirror.copyState(htmlMode, state.htmlState),\n          rubyState: CodeMirror.copyState(rubyMode, state.rubyState),\n          indented: state.indented,\n          previousToken: state.previousToken,\n          tokenize: state.tokenize\n        };\n      },\n\n      token: function(stream, state) {\n        if (stream.sol()) {\n          state.indented = stream.indentation();\n          state.startOfLine = true;\n        }\n        if (stream.eatSpace()) return null;\n        var style = state.tokenize(stream, state);\n        state.startOfLine = false;\n        // dont record comment line as we only want to measure comment line with\n        // the opening comment block\n        if (style && style != \"commentLine\") {\n          state.previousToken = { style: style, indented: state.indented };\n        }\n        // if current state is ruby and the previous token is not `,` reset the\n        // tokenize to html\n        if (stream.eol() && state.tokenize == ruby) {\n          stream.backUp(1);\n          var ch = stream.peek();\n          stream.next();\n          if (ch && ch != \",\") {\n            state.tokenize = html;\n          }\n        }\n        // reprocess some of the specific style tag when finish setting previousToken\n        if (style == \"hamlTag\") {\n          style = \"tag\";\n        } else if (style == \"commentLine\") {\n          style = \"comment\";\n        } else if (style == \"hamlAttribute\") {\n          style = \"attribute\";\n        } else if (style == \"closeAttributeTag\") {\n          style = null;\n        }\n        return style;\n      }\n    };\n  }, \"htmlmixed\", \"ruby\");\n\n  CodeMirror.defineMIME(\"text/x-haml\", \"haml\");\n});\n"]},"metadata":{},"sourceType":"script"}