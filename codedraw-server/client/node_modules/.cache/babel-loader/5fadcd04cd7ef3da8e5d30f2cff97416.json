{"ast":null,"code":"// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n(function (mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);else // Plain browser env\n    mod(CodeMirror);\n})(function (CodeMirror) {\n  \"use strict\";\n\n  function wordRegexp(words) {\n    return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n  }\n\n  ;\n  var builtinArray = [\"Clamp\", \"Constructor\", \"EnforceRange\", \"Exposed\", \"ImplicitThis\", \"Global\", \"PrimaryGlobal\", \"LegacyArrayClass\", \"LegacyUnenumerableNamedProperties\", \"LenientThis\", \"NamedConstructor\", \"NewObject\", \"NoInterfaceObject\", \"OverrideBuiltins\", \"PutForwards\", \"Replaceable\", \"SameObject\", \"TreatNonObjectAsNull\", \"TreatNullAs\", \"EmptyString\", \"Unforgeable\", \"Unscopeable\"];\n  var builtins = wordRegexp(builtinArray);\n  var typeArray = [\"unsigned\", \"short\", \"long\", // UnsignedIntegerType\n  \"unrestricted\", \"float\", \"double\", // UnrestrictedFloatType\n  \"boolean\", \"byte\", \"octet\", // Rest of PrimitiveType\n  \"Promise\", // PromiseType\n  \"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Int16Array\", \"Int32Array\", \"Uint8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8ClampedArray\", \"Float32Array\", \"Float64Array\", // BufferRelatedType\n  \"ByteString\", \"DOMString\", \"USVString\", \"sequence\", \"object\", \"RegExp\", \"Error\", \"DOMException\", \"FrozenArray\", // Rest of NonAnyType\n  \"any\", // Rest of SingleType\n  \"void\" // Rest of ReturnType\n  ];\n  var types = wordRegexp(typeArray);\n  var keywordArray = [\"attribute\", \"callback\", \"const\", \"deleter\", \"dictionary\", \"enum\", \"getter\", \"implements\", \"inherit\", \"interface\", \"iterable\", \"legacycaller\", \"maplike\", \"partial\", \"required\", \"serializer\", \"setlike\", \"setter\", \"static\", \"stringifier\", \"typedef\", // ArgumentNameKeyword except\n  // \"unrestricted\"\n  \"optional\", \"readonly\", \"or\"];\n  var keywords = wordRegexp(keywordArray);\n  var atomArray = [\"true\", \"false\", // BooleanLiteral\n  \"Infinity\", \"NaN\", // FloatLiteral\n  \"null\" // Rest of ConstValue\n  ];\n  var atoms = wordRegexp(atomArray);\n  CodeMirror.registerHelper(\"hintWords\", \"webidl\", builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray));\n  var startDefArray = [\"callback\", \"dictionary\", \"enum\", \"interface\"];\n  var startDefs = wordRegexp(startDefArray);\n  var endDefArray = [\"typedef\"];\n  var endDefs = wordRegexp(endDefArray);\n  var singleOperators = /^[:<=>?]/;\n  var integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;\n  var floats = /^-?(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;\n  var identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;\n  var identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\\s*;)/;\n  var strings = /^\"[^\"]*\"/;\n  var multilineComments = /^\\/\\*.*?\\*\\//;\n  var multilineCommentsStart = /^\\/\\*.*/;\n  var multilineCommentsEnd = /^.*?\\*\\//;\n\n  function readToken(stream, state) {\n    // whitespace\n    if (stream.eatSpace()) return null; // comment\n\n    if (state.inComment) {\n      if (stream.match(multilineCommentsEnd)) {\n        state.inComment = false;\n        return \"comment\";\n      }\n\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    if (stream.match(\"//\")) {\n      stream.skipToEnd();\n      return \"comment\";\n    }\n\n    if (stream.match(multilineComments)) return \"comment\";\n\n    if (stream.match(multilineCommentsStart)) {\n      state.inComment = true;\n      return \"comment\";\n    } // integer and float\n\n\n    if (stream.match(/^-?[0-9\\.]/, false)) {\n      if (stream.match(integers) || stream.match(floats)) return \"number\";\n    } // string\n\n\n    if (stream.match(strings)) return \"string\"; // identifier\n\n    if (state.startDef && stream.match(identifiers)) return \"def\";\n\n    if (state.endDef && stream.match(identifiersEnd)) {\n      state.endDef = false;\n      return \"def\";\n    }\n\n    if (stream.match(keywords)) return \"keyword\";\n\n    if (stream.match(types)) {\n      var lastToken = state.lastToken;\n      var nextToken = (stream.match(/^\\s*(.+?)\\b/, false) || [])[1];\n\n      if (lastToken === \":\" || lastToken === \"implements\" || nextToken === \"implements\" || nextToken === \"=\") {\n        // Used as identifier\n        return \"builtin\";\n      } else {\n        // Used as type\n        return \"variable-3\";\n      }\n    }\n\n    if (stream.match(builtins)) return \"builtin\";\n    if (stream.match(atoms)) return \"atom\";\n    if (stream.match(identifiers)) return \"variable\"; // other\n\n    if (stream.match(singleOperators)) return \"operator\"; // unrecognized\n\n    stream.next();\n    return null;\n  }\n\n  ;\n  CodeMirror.defineMode(\"webidl\", function () {\n    return {\n      startState: function startState() {\n        return {\n          // Is in multiline comment\n          inComment: false,\n          // Last non-whitespace, matched token\n          lastToken: \"\",\n          // Next token is a definition\n          startDef: false,\n          // Last token of the statement is a definition\n          endDef: false\n        };\n      },\n      token: function token(stream, state) {\n        var style = readToken(stream, state);\n\n        if (style) {\n          var cur = stream.current();\n          state.lastToken = cur;\n\n          if (style === \"keyword\") {\n            state.startDef = startDefs.test(cur);\n            state.endDef = state.endDef || endDefs.test(cur);\n          } else {\n            state.startDef = false;\n          }\n        }\n\n        return style;\n      }\n    };\n  });\n  CodeMirror.defineMIME(\"text/x-webidl\", \"webidl\");\n});","map":{"version":3,"sources":["/Users/akshatgarg/Documents/codedraw-server/client/node_modules/@uiw/react-codemirror/node_modules/codemirror/mode/webidl/webidl.js"],"names":["mod","exports","module","require","define","amd","CodeMirror","wordRegexp","words","RegExp","join","builtinArray","builtins","typeArray","types","keywordArray","keywords","atomArray","atoms","registerHelper","concat","startDefArray","startDefs","endDefArray","endDefs","singleOperators","integers","floats","identifiers","identifiersEnd","strings","multilineComments","multilineCommentsStart","multilineCommentsEnd","readToken","stream","state","eatSpace","inComment","match","skipToEnd","startDef","endDef","lastToken","nextToken","next","defineMode","startState","token","style","cur","current","test","defineMIME"],"mappings":"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","sourcesContent":["// CodeMirror, copyright (c) by Marijn Haverbeke and others\n// Distributed under an MIT license: https://codemirror.net/LICENSE\n\n(function(mod) {\n  if (typeof exports == \"object\" && typeof module == \"object\") // CommonJS\n    mod(require(\"../../lib/codemirror\"));\n  else if (typeof define == \"function\" && define.amd) // AMD\n    define([\"../../lib/codemirror\"], mod);\n  else // Plain browser env\n    mod(CodeMirror);\n})(function(CodeMirror) {\n\"use strict\";\n\nfunction wordRegexp(words) {\n  return new RegExp(\"^((\" + words.join(\")|(\") + \"))\\\\b\");\n};\n\nvar builtinArray = [\n  \"Clamp\",\n  \"Constructor\",\n  \"EnforceRange\",\n  \"Exposed\",\n  \"ImplicitThis\",\n  \"Global\", \"PrimaryGlobal\",\n  \"LegacyArrayClass\",\n  \"LegacyUnenumerableNamedProperties\",\n  \"LenientThis\",\n  \"NamedConstructor\",\n  \"NewObject\",\n  \"NoInterfaceObject\",\n  \"OverrideBuiltins\",\n  \"PutForwards\",\n  \"Replaceable\",\n  \"SameObject\",\n  \"TreatNonObjectAsNull\",\n  \"TreatNullAs\",\n    \"EmptyString\",\n  \"Unforgeable\",\n  \"Unscopeable\"\n];\nvar builtins = wordRegexp(builtinArray);\n\nvar typeArray = [\n  \"unsigned\", \"short\", \"long\",                  // UnsignedIntegerType\n  \"unrestricted\", \"float\", \"double\",            // UnrestrictedFloatType\n  \"boolean\", \"byte\", \"octet\",                   // Rest of PrimitiveType\n  \"Promise\",                                    // PromiseType\n  \"ArrayBuffer\", \"DataView\", \"Int8Array\", \"Int16Array\", \"Int32Array\",\n  \"Uint8Array\", \"Uint16Array\", \"Uint32Array\", \"Uint8ClampedArray\",\n  \"Float32Array\", \"Float64Array\",               // BufferRelatedType\n  \"ByteString\", \"DOMString\", \"USVString\", \"sequence\", \"object\", \"RegExp\",\n  \"Error\", \"DOMException\", \"FrozenArray\",       // Rest of NonAnyType\n  \"any\",                                        // Rest of SingleType\n  \"void\"                                        // Rest of ReturnType\n];\nvar types = wordRegexp(typeArray);\n\nvar keywordArray = [\n  \"attribute\", \"callback\", \"const\", \"deleter\", \"dictionary\", \"enum\", \"getter\",\n  \"implements\", \"inherit\", \"interface\", \"iterable\", \"legacycaller\", \"maplike\",\n  \"partial\", \"required\", \"serializer\", \"setlike\", \"setter\", \"static\",\n  \"stringifier\", \"typedef\",                     // ArgumentNameKeyword except\n                                                // \"unrestricted\"\n  \"optional\", \"readonly\", \"or\"\n];\nvar keywords = wordRegexp(keywordArray);\n\nvar atomArray = [\n  \"true\", \"false\",                              // BooleanLiteral\n  \"Infinity\", \"NaN\",                            // FloatLiteral\n  \"null\"                                        // Rest of ConstValue\n];\nvar atoms = wordRegexp(atomArray);\n\nCodeMirror.registerHelper(\"hintWords\", \"webidl\",\n    builtinArray.concat(typeArray).concat(keywordArray).concat(atomArray));\n\nvar startDefArray = [\"callback\", \"dictionary\", \"enum\", \"interface\"];\nvar startDefs = wordRegexp(startDefArray);\n\nvar endDefArray = [\"typedef\"];\nvar endDefs = wordRegexp(endDefArray);\n\nvar singleOperators = /^[:<=>?]/;\nvar integers = /^-?([1-9][0-9]*|0[Xx][0-9A-Fa-f]+|0[0-7]*)/;\nvar floats = /^-?(([0-9]+\\.[0-9]*|[0-9]*\\.[0-9]+)([Ee][+-]?[0-9]+)?|[0-9]+[Ee][+-]?[0-9]+)/;\nvar identifiers = /^_?[A-Za-z][0-9A-Z_a-z-]*/;\nvar identifiersEnd = /^_?[A-Za-z][0-9A-Z_a-z-]*(?=\\s*;)/;\nvar strings = /^\"[^\"]*\"/;\nvar multilineComments = /^\\/\\*.*?\\*\\//;\nvar multilineCommentsStart = /^\\/\\*.*/;\nvar multilineCommentsEnd = /^.*?\\*\\//;\n\nfunction readToken(stream, state) {\n  // whitespace\n  if (stream.eatSpace()) return null;\n\n  // comment\n  if (state.inComment) {\n    if (stream.match(multilineCommentsEnd)) {\n      state.inComment = false;\n      return \"comment\";\n    }\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (stream.match(\"//\")) {\n    stream.skipToEnd();\n    return \"comment\";\n  }\n  if (stream.match(multilineComments)) return \"comment\";\n  if (stream.match(multilineCommentsStart)) {\n    state.inComment = true;\n    return \"comment\";\n  }\n\n  // integer and float\n  if (stream.match(/^-?[0-9\\.]/, false)) {\n    if (stream.match(integers) || stream.match(floats)) return \"number\";\n  }\n\n  // string\n  if (stream.match(strings)) return \"string\";\n\n  // identifier\n  if (state.startDef && stream.match(identifiers)) return \"def\";\n\n  if (state.endDef && stream.match(identifiersEnd)) {\n    state.endDef = false;\n    return \"def\";\n  }\n\n  if (stream.match(keywords)) return \"keyword\";\n\n  if (stream.match(types)) {\n    var lastToken = state.lastToken;\n    var nextToken = (stream.match(/^\\s*(.+?)\\b/, false) || [])[1];\n\n    if (lastToken === \":\" || lastToken === \"implements\" ||\n        nextToken === \"implements\" || nextToken === \"=\") {\n      // Used as identifier\n      return \"builtin\";\n    } else {\n      // Used as type\n      return \"variable-3\";\n    }\n  }\n\n  if (stream.match(builtins)) return \"builtin\";\n  if (stream.match(atoms)) return \"atom\";\n  if (stream.match(identifiers)) return \"variable\";\n\n  // other\n  if (stream.match(singleOperators)) return \"operator\";\n\n  // unrecognized\n  stream.next();\n  return null;\n};\n\nCodeMirror.defineMode(\"webidl\", function() {\n  return {\n    startState: function() {\n      return {\n        // Is in multiline comment\n        inComment: false,\n        // Last non-whitespace, matched token\n        lastToken: \"\",\n        // Next token is a definition\n        startDef: false,\n        // Last token of the statement is a definition\n        endDef: false\n      };\n    },\n    token: function(stream, state) {\n      var style = readToken(stream, state);\n\n      if (style) {\n        var cur = stream.current();\n        state.lastToken = cur;\n        if (style === \"keyword\") {\n          state.startDef = startDefs.test(cur);\n          state.endDef = state.endDef || endDefs.test(cur);\n        } else {\n          state.startDef = false;\n        }\n      }\n\n      return style;\n    }\n  };\n});\n\nCodeMirror.defineMIME(\"text/x-webidl\", \"webidl\");\n});\n"]},"metadata":{},"sourceType":"script"}